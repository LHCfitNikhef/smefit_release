(* ::Package:: *)

BeginPackage["MMEFT2SMEFiT`"];


":Name: MMEFT2SMEFiT@1loop"
":Version: 1.1beta"
":Author: Alejo N. Rossia"
":Affiliation: Department of Physics and Astronomy, The University of Manchester."


Print["MMEFT2SMEFiT@1loop: an interface between matchmakereft and SMEFiT prepared for 1 loop matching."];
Print["Version: 1.1 beta"];
Print["Date: 21/07/2023"];
Print["Author: Alejo N. Rossia"];
Print["Affiliations: The University of Manchester"];


matcher::usage = "matcher[directory,model] takes the file model.fr in directory and related files and performs the matching of SM+model to the SMEFT at tree level.";
parametersList::usage = "parametersList[directory,model] reads the file directory/model.fr, identifies the couplings and masses of the UV model and returns a list with them.";
parametersListFromMatchingResult::usage = "parametersListFromMatchingResult[matchingResultFile] reads the MatchingResult.dat file generated by MMEFT, identifies the couplings 
and masses of the UV model and returns a list with them.";
matchResToUVscanCard::usage = "matchResToUVscanCard[matchResFile,mass,OptionalArguments] reads the file matchResFile and
prints the run card for a fit on the UV couplings and the card that defines the corresponding UV invariants. It also takes mandatorily a value for the mass of the UV particles which is applied only 
when producing the run cards. The OptionalArguments are \"UVFlavourAssumption\", \"Collection\" and \"Model\". An example of how to set them, using their default values is, {\"UVFlavourAssumption\"->{},\"Collection\"->\"UserCollection\",\"Model\"->\"UserModel\"}.";
(*matchResToWCscanCard::usage = "matchResToWCscanCard[matchResFile,mass,OptionalArguments] reads the file matchResFile and
prints the run card for a fit on the UV couplings and the card that defines the corresponding UV invariants. It also takes mandatorily a value for the mass of the UV particles which is applied only 
when producing the run cards. The OptionalArguments are \"UVFlavourAssumption\", \"Collection\" and \"Model\". An example of how to set them, using their default values is, {\"UVFlavourAssumption\"->{},\"Collection\"->\"UserCollection\",\"Model\"->\"UserModel\"}.";
*)modelToUVscanCard::usage = "modelToUVscanCard[directory,model,mass,OptionalArguments] reads the file directory\\model.fr (usually the input directory already contains
the \), runs MMEFT to add that model to the SM and match it onto SMEFT, reads the results and prints the run card for a fit on the UV couplings and the card that defines the corresponding UV invariants.
It also takes mandatorily a value for the mass of the UV particles which is applied only when producing the run cards. The OptionalArguments are \"UVFlavourAssumption\" and \"Collection\". An example of how to set them, using their default value is, {\"UVFlavourAssumption\"->{},\"Collection\"->\"UserCollection\"}.";
(*modelToWCscanCard::usage = "modelToWCscanCard[directory,model,mass,OptionalArguments] reads the file directory\\model.fr (usually the input directory already contains
the \), runs MMEFT to add that model to the SM and match it onto SMEFT, reads the results and prints the run card for a fit on the WCs and the card that defines the corresponding UV invariants.
It also takes mandatorily a value for the mass of the UV particles which is applied only when producing the run cards. The OptionalArguments are \"UVFlavourAssumption\" and \"Collection\". An example of how to set them, using their default value is, {\"UVFlavourAssumption\"->{},\"Collection\"->\"UserCollection\"}.";
*)invariantBuilder::usage = "Test"


Begin["`Private`"];


(* ::Section::Closed:: *)
(*Utility functions*)


(*/// Function that defines convenient aliases for the WCs to print ///*)
printNameWCs[x_]:=Piecewise[{{"c81qq",ToString[x]=="wwCQq18"},{"c11qq",ToString[x]=="wwCQq11"},{"c83qq",ToString[x]=="wwCQq38"},{"c13qq",ToString[x]=="wwCQq31"},{"c8qt",ToString[x]=="wwCtq8"},{"c1qt",ToString[x]=="wwCtq1"},{"c8ut",ToString[x]=="wwCtu8"},{"c1ut",ToString[x]=="wwCtu1"},{"c8qu",ToString[x]=="wwCQu8"},{"c1qu",ToString[x]=="wwCQu1"},{"c8dt",ToString[x]=="wwCtd8"},{"c1dt",ToString[x]=="wwCtd1"},{"c8qd",ToString[x]=="wwCQd8"},{"c1qd",ToString[x]=="wwCQd1"},{"cQQ1",ToString[x]=="wwCQQ1"},{"cQQ8",ToString[x]=="wwCQQ8"},{"cQt1",ToString[x]=="wwCQt1"},{"cQt8",ToString[x]=="wwCQt8"},{"ctt1",ToString[x]=="wwCtt1"},{"cll",ToString[x]=="wwCll"},{"cbp",ToString[x]=="wwCb\[CurlyPhi]"},{"ctp",ToString[x]=="wwCt\[CurlyPhi]"},{"ctG",ToString[x]=="wwCtG"},{"ccp",ToString[x]=="wwCc\[CurlyPhi]"},{"ctap",ToString[x]=="wwC\[Tau]\[CurlyPhi]"},{"ctW",ToString[x]=="wwCtW"},{"ctZ",ToString[x]=="wwCtZ"},{"c3pQ3",ToString[x]=="wwC\[CurlyPhi]Q3"},{"cpQM",ToString[x]=="wwC\[CurlyPhi]Qm"},{"cpt",ToString[x]=="wwC\[CurlyPhi]t"},{"cpl1",ToString[x]=="wwC\[CurlyPhi]l11"},{"c3pl1",ToString[x]=="wwC\[CurlyPhi]l31"},{"cpl2",ToString[x]=="wwC\[CurlyPhi]l12"},{"c3pl2",ToString[x]=="wwC\[CurlyPhi]l32"},{"cpl3",ToString[x]=="wwC\[CurlyPhi]l13"},{"c3pl3",ToString[x]=="wwC\[CurlyPhi]l33"},{"cpe",ToString[x]=="wwC\[CurlyPhi]e"},{"cpmu",ToString[x]=="wwC\[CurlyPhi]\[Mu]"},{"cpta",ToString[x]=="wwC\[CurlyPhi]\[Tau]"},{"c3pq",ToString[x]=="wwC\[CurlyPhi]q3"},{"cpqMi",ToString[x]=="wwC\[CurlyPhi]qm"},{"cpui",ToString[x]=="wwC\[CurlyPhi]ui"},{"cpdi",ToString[x]=="wwC\[CurlyPhi]di"},{"cpG",ToString[x]=="wwC\[CurlyPhi]G"},{"cpB",ToString[x]=="wwC\[CurlyPhi]B"},{"cpW",ToString[x]=="wwC\[CurlyPhi]W"},{"cpd",ToString[x]=="wwC\[CurlyPhi]d"},{"cpWB",ToString[x]=="wwC\[CurlyPhi]WB"},{"cpD",ToString[x]=="wwC\[CurlyPhi]D"},{"cWWW",ToString[x]=="wwCWWW"}}];
(*Original function taken from: https://mathematica.stackexchange.com/a/250929 *)
Clear[EinsteinSum]
EinsteinSum[Times[a___,(p_Symbol)[x___,i_Symbol,y___],b___,(q_Symbol)[w___,i_Symbol,z___],c___]]:=EinsteinSum[a b c With[{ii=Unique["ii"]},Sum[p[x,ii,y] q[w,ii,z],{ii,3}]]]
EinsteinSum[Times[a___,Power[(b_Symbol)[x___,i_Symbol,y___],2],c___]]:=EinsteinSum[a c With[{ii=Unique["ii"]},Sum[b[x,ii,y] b[x,ii,y],{ii,3}]]]
EinsteinSum[Times[a___,Power[(b_Symbol)[x___,i_Symbol,y___],4],c___]]:=EinsteinSum[a c With[{ii=Unique["ii"]},Sum[b[x,ii,y]^4,{ii,3}]]]
EinsteinSum[Times[a_,b__]]:=EinsteinSum[Expand[a b]]/;!SameQ[a b,Expand[a b]]
EinsteinSum[Plus[a_,b__]]:=Plus@@(EinsteinSum/@{a,b})
Attributes[EinsteinSum]={Listable};
EinsteinSum[x_]:=x;
(*Original function from: https://mathematica.stackexchange.com/a/124441 *)
Clear[funfac];
funfac[a_*b_]:=funfac[a]*funfac[b];
funfac[a_+b_]:=funfac[a]+funfac[b];
funfac[a_^b_]:=funfac[a];
funfac[a_?NumericQ]:=a;
funfac[s_Symbol]:=1;
funfac[s_Symbol[___]]:=1;
funfac[s_Symbol[___][___]]:=1;
funfac[s_Symbol[___][___][___]]:=1;
reempSquaredDeltasEinstein={KroneckerDelta[a_,b_]^2:>Block[{var,fixed},fixed=Piecewise[{{a,Evaluate[NumericQ[a]]}},b];var=Piecewise[{{b,Evaluate[NumericQ[a]]}},a];Sum[KroneckerDelta[fixed,var]^2,{var,1,3}]]};
wcVarDecomp[wc_]:=Block[{var,exp},var=Variables[wc];
exp=Exponent[wc,var];
SortBy[Table[{var[[i]],exp[[i]]},{i,1,Length[var]}],(#[[2]])&]];
findLowestExponent[row_]:=Block[{ret,n},ret=0;n=1;While[ret==0&&n<=1000,If[MemberQ[row,(-1)^(n+1)*Quotient[n+1,2]],ret=(-1)^(n+1)*Quotient[n+1,2],n++]];ret];


writeStrBlock[varsUV_][elem_,index_]:=Block[{tab},tab=Table[ToString[CForm[varsUV[[i]]]]<>": ["<>Piecewise[{{StringReplace[ToString[InputForm[elem]],"*^"->"e"],i==1}},"1"]<>","<>ToString[index[[i]]-1]<>"]"<>Piecewise[{{",",i<Length[varsUV]}},""],{i,1,Length[varsUV]}];
"{"<>StringJoin[tab]<>"}"]
(**)
reCastString[term_]:=Block[{temp},temp=StringSplit[StringSplit[StringTrim[term,{"{","}"}],","],":"];
ToExpression[Table[Join[StringReplace[StringTrim[temp[[2*i-1]],{" [","]"}],"J"->"I"],StringReplace[StringTrim[temp[[2*i]],{"[","]"}],"J"->"I"]],{i,1,Length[temp]/2}]]];
(**)
reempMultRelPrint[term_,dictFinal_,reempMultRel_,reempWCnames_]:=Block[{ret,data,alfa,wcsMultRed,posWcsMultRed,decompWCsMultRed,posFinalWCsdata,finalDecomp},data=reCastString[term];
(*// Case of vanishing term. //*)
If[data[[1,2]]==0,Return[Flatten[MapIndexed[writeStrBlock[dictFinal/.reempWCnames],CoefficientList[N[0],dictFinal],{Length[dictFinal]}]][[1]]]];
(*// Case in which we have to replace mult. red. WCs. //*)
If[Length[reempMultRel]>0,
alfa=data[[1,2]];(*Numerical coefficient of the term*)
wcsMultRed=reempMultRel[[;;,1]];(*WCs that must be replaced with multiplicative relations.*)
decompWCsMultRed=Table[{reempMultRel[[i,1]],decompMultRelations[reempMultRel[[i]],dictFinal]},{i,1,Length[reempMultRel]}];(*// Decomposes the mult. red. WCs. in the final basis. //*)
posWcsMultRed=Table[Position[data[[;;,1]],wcsMultRed[[i]]][[1,1]],{i,1,Length[wcsMultRed]}]; (*// Position of the mult. red. WCs in the decomposition. //*)
posFinalWCsdata=Table[Position[data[[;;,1]],dictFinal[[j]]][[1,1]],{j,1,Length[dictFinal]}]; (*// Position of the WCs in the final basis in the data. Complement is not good due to possible order change. //*)
alfa=alfa*Product[decompWCsMultRed[[i,2,1,2]]^(data[[posWcsMultRed[[i]],3]]),{i,1,Length[reempMultRel]}];(*// Computes the corrected numerical factor after replacing the mult. red. WCs. //*)
finalDecomp=Table[{dictFinal[[i]],1,data[[posFinalWCsdata[[i]],3]]+Sum[data[[posWcsMultRed[[k]],3]]*decompWCsMultRed[[k,2,i,3]],{k,1,Length[decompWCsMultRed]}]},{i,1,Length[dictFinal]}];
finalDecomp[[1,2]]=alfa;(*// Assigns the correct numerical coefficient //*)
Return[StringReplace[StringReplace[ToString[InputForm[Flatten[Table[{ToString[finalDecomp[[i,1]]/.reempWCnames]<>":","["<>ToString[N[finalDecomp[[i,2]],12]],ToString[InputForm[N[finalDecomp[[i,3]]]]]<>"]"},{i,1,Length[finalDecomp]}]]]],"\""->""],{":, ["->": [","I,"->"J,"}]]
];
(*// Case in which we do NOT have to replace mult. red. WCs. //*)
Return[StringReplace[term,If[Length[reempWCnames]>0,Table[ToString[reempWCnames[[j,1]]]->ToString[reempWCnames[[j,2]]],{j,1,Length[reempWCnames]}],{}]]];
];
(**)
testSign[f_]:=Block[{vars,tab,jInd,ret},If[NumericQ[f],ret=Piecewise[{{"Pos",Positive[f]},{"Neg",Negative[f]}},"ND"],vars=Variables[f];
(*This method is quite crude and neglects the possibility of cancellations among summed terms*)
tab=Table[f/.{vars[[1]]->k},{k,{-RandomReal[10^3],RandomReal[10^3]}}];
For[jInd=2,jInd<=Length[vars],jInd++,
tab=Table[tab/.{vars[[jInd]]->k},{k,{-RandomReal[10^3],RandomReal[10^3]}}];];
tab=Flatten[tab];
ret=Piecewise[{{"Pos",Min[tab]>0},{"Neg",Max[tab]<0}},"ND"];];
ret]
(**)
printMultRelNew[reempMultRel_,dictFinal_,reempNamesRelev_]:=Block[{decomp},
decomp=decompMultRelations[reempMultRel,dictFinal];
Return[StringReplace[StringReplace[ToString[InputForm[Flatten[Table[{ToString[decomp[[i,1]]/.reempNamesRelev]<>":","["<>ToString[N[decomp[[i,2]],12]],ToString[InputForm[N[decomp[[i,3]]]]]<>"]"},{i,1,Length[decomp]}]]]],"\""->""],{":, ["->": [","I,"->"J,"}]]];
(**)
numFactMultRelations[reempMultRel_,dictFinal_,listExpo_]:=Block[{posNoZero,dummyReemp},posNoZero=Position[listExpo,_?(!SameQ[#,0]&&NumericQ[#]&)][[;;,1]];
dummyReemp={dictFinal[[posNoZero[[1]]]]->u^(1/listExpo[[posNoZero[[1]]]])*Product[dictFinal[[j]]^(-listExpo[[j]]/listExpo[[posNoZero[[1]]]]),{j,DeleteCases[Table[k,{k,1,Length[dictFinal]}],posNoZero[[1]]]}]};
Coefficient[Simplify[reempMultRel[[2]]/.dummyReemp/.Table[dictFinal[[i]]->1,{i,1,Length[dictFinal]}],{u\[Element]Reals,u>0}],u,1]
];
(**)
decompMultRelations[reempMultRel_,dictFinal_]:=Block[{listExpo,numFac,ret},listExpo=Exponent[N[reempMultRel[[2]]/.{m->1}],dictFinal];
ret=Table[{dictFinal[[i]],1,listExpo[[i]]},{i,1,Length[dictFinal]}];
numFac=numFactMultRelations[reempMultRel,dictFinal,listExpo];
ret[[1,2]]=numFac;
ret];
funcRemoveZeros[list_]:=Block[{ret,pattern,limiters},If[Length[list]<=1,ret=list,
pattern="["~~RegularExpression["[\\-]?[0-9]+(\\.)*[0-9]*"]~~","~~RegularExpression["[\\-]?[0-9]+(\\.)*[0-9]*"]~~"]";
limiters={"[",",","]"};
ret=Select[list,(StringSplit[StringCases[#,pattern],limiters][[1,1]]!="0"&&StringSplit[StringCases[#, pattern], limiters][[1,1]]!="0.")&];
];
ret
];
massHandler[matchResFile_,mass_,flaUVassum_]:=Block[{dicTotal,preVarsUV,massString,massInt,massIntList,massReemp},
If[Length[mass]>1,
{dicTotal,preVarsUV}=dictionaryToPrintMultiPart[matchResFile]/.{Symbol[SymbolName[onelooporder]]->1}/.flaUVassum;
(*preVarsUV stores the names of the recognised UV masses.*)
massString=StringRiffle[ToString/@IntegerPart/@mass,""];
If[Length[mass]<Length[preVarsUV],
massInt=mass[[-1]];
massIntList=Nest[Append[#,massInt]&,mass,Length[preVarsUV]-Length[mass]];
massReemp=Table[Symbol[SymbolName[m]<>ToString[j]]->massIntList[[j]],{j,1,Length[preVarsUV]}];
,
massReemp=Table[Symbol[SymbolName[m]<>ToString[j]]->mass[[j]],{j,1,Length[preVarsUV]}];
];
,
massInt=Piecewise[{{mass[[1]],Length[mass]==1}},mass];
massString=ToString[massInt];
dicTotal=dictionaryToPrint[matchResFile]/.{Symbol[SymbolName[onelooporder]]->1}/.flaUVassum;
massReemp={Symbol[SymbolName[m]]->massInt};];
{dicTotal,massString,massReemp}]


(* ::Section::Closed:: *)
(*MMEFT conventions*)


(*Code prepared for tree-level matching results only. *)
renormReemp:={Symbol[SymbolName[onelooporder]]->1,Symbol[SymbolName[epsilonbar]]->0,Symbol[SymbolName[invepsilonbar]]->0};
leviCivitaConvention:={iCPV->1};
(*/// MMEFT WC naming convention. ///*)
listWCsMatchMakerEFT:={alphaKB,alphaKW,alphaKG,alphaKq[mif1_,mif2_],alphaKl[mif1_,mif2_],alphaKu[mif1_,mif2_],alphaKd[mif1_,mif2_],alphaKe[mif1_,mif2_],alphaOmuH2,alphaKH,alphaOlambda,alphaOlambdad[mif1_,mif2_],alphaOlambdae[mif1_,mif2_],alphaOlambdau[mif1_,mif2_],alphaKqbar[mif1_,mif2_],alphaKlbar[mif1_,mif2_],alphaKubar[mif1_,mif2_],alphaKdbar[mif1_,mif2_],alphaKebar[mif1_,mif2_],alphaOlambdadbar[mif1_,mif2_],alphaOlambdaebar[mif1_,mif2_],alphaOlambdaubar[mif1_,mif2_],alphaO3G,alphaO3Gt,alphaO3W,alphaO3Wt,alphaOHG,alphaOHGt,alphaOHW,alphaOHWt,alphaOHB,alphaOHBt,alphaOHWB,alphaOHWBt,alphaOHBox,alphaOHD,alphaOH,alphaOuG[mif1_,mif2_],alphaOuW[mif1_,mif2_],alphaOuB[mif1_,mif2_],alphaOdG[mif1_,mif2_],alphaOdW[mif1_,mif2_],alphaOdB[mif1_,mif2_],alphaOeW[mif1_,mif2_],alphaOeB[mif1_,mif2_],alphaOHq1[mif1_,mif2_],alphaOHq3[mif1_,mif2_],alphaOHu[mif1_,mif2_],alphaOHd[mif1_,mif2_],alphaOHud[mif1_,mif2_],alphaOHl1[mif1_,mif2_],alphaOHl3[mif1_,mif2_],alphaOHe[mif1_,mif2_],alphaOuH[mif1_,mif2_],alphaOdH[mif1_,mif2_],alphaOeH[mif1_,mif2_],alphaOuGbar[mif1_,mif2_],alphaOuWbar[mif1_,mif2_],alphaOuBbar[mif1_,mif2_],alphaOdGbar[mif1_,mif2_],alphaOdWbar[mif1_,mif2_],alphaOdBbar[mif1_,mif2_],alphaOeWbar[mif1_,mif2_],alphaOeBbar[mif1_,mif2_],alphaOHq1bar[mif1_,mif2_],alphaOHq3bar[mif1_,mif2_],alphaOHubar[mif1_,mif2_],alphaOHdbar[mif1_,mif2_],alphaOHudbar[mif1_,mif2_],alphaOHl1bar[mif1_,mif2_],alphaOHl3bar[mif1_,mif2_],alphaOHebar[mif1_,mif2_],alphaOuHbar[mif1_,mif2_],alphaOdHbar[mif1_,mif2_],alphaOeHbar[mif1_,mif2_],alphaOqq1[mif1_,mif2_,mif3_,mif4_],alphaOqq3[mif1_,mif2_,mif3_,mif4_],alphaOuu[mif1_,mif2_,mif3_,mif4_],alphaOdd[mif1_,mif2_,mif3_,mif4_],alphaOud1[mif1_,mif2_,mif3_,mif4_],alphaOud8[mif1_,mif2_,mif3_,mif4_],alphaOqu1[mif1_,mif2_,mif3_,mif4_],alphaOqu8[mif1_,mif2_,mif3_,mif4_],alphaOqd1[mif1_,mif2_,mif3_,mif4_],alphaOqd8[mif1_,mif2_,mif3_,mif4_],alphaOquqd1[mif1_,mif2_,mif3_,mif4_],alphaOquqd8[mif1_,mif2_,mif3_,mif4_],alphaOll[mif1_,mif2_,mif3_,mif4_],alphaOee[mif1_,mif2_,mif3_,mif4_],alphaOle[mif1_,mif2_,mif3_,mif4_],alphaOlq1[mif1_,mif2_,mif3_,mif4_],alphaOlq3[mif1_,mif2_,mif3_,mif4_],alphaOeu[mif1_,mif2_,mif3_,mif4_],alphaOed[mif1_,mif2_,mif3_,mif4_],alphaOqe[mif1_,mif2_,mif3_,mif4_],alphaOlu[mif1_,mif2_,mif3_,mif4_],alphaOld[mif1_,mif2_,mif3_,mif4_],alphaOledq[mif1_,mif2_,mif3_,mif4_],alphaOlequ1[mif1_,mif2_,mif3_,mif4_],alphaOlequ3[mif1_,mif2_,mif3_,mif4_],alphaOqq1bar[mif1_,mif2_,mif3_,mif4_],alphaOqq3bar[mif1_,mif2_,mif3_,mif4_],alphaOuubar[mif1_,mif2_,mif3_,mif4_],alphaOddbar[mif1_,mif2_,mif3_,mif4_],alphaOud1bar[mif1_,mif2_,mif3_,mif4_],alphaOud8bar[mif1_,mif2_,mif3_,mif4_],alphaOqu1bar[mif1_,mif2_,mif3_,mif4_],alphaOqu8bar[mif1_,mif2_,mif3_,mif4_],alphaOqd1bar[mif1_,mif2_,mif3_,mif4_],alphaOqd8bar[mif1_,mif2_,mif3_,mif4_],alphaOquqd1bar[mif1_,mif2_,mif3_,mif4_],alphaOquqd8bar[mif1_,mif2_,mif3_,mif4_],alphaOllbar[mif1_,mif2_,mif3_,mif4_],alphaOeebar[mif1_,mif2_,mif3_,mif4_],alphaOlebar[mif1_,mif2_,mif3_,mif4_],alphaOlq1bar[mif1_,mif2_,mif3_,mif4_],alphaOlq3bar[mif1_,mif2_,mif3_,mif4_],alphaOeubar[mif1_,mif2_,mif3_,mif4_],alphaOedbar[mif1_,mif2_,mif3_,mif4_],alphaOqebar[mif1_,mif2_,mif3_,mif4_],alphaOlubar[mif1_,mif2_,mif3_,mif4_],alphaOldbar[mif1_,mif2_,mif3_,mif4_],alphaOledqbar[mif1_,mif2_,mif3_,mif4_],alphaOlequ1bar[mif1_,mif2_,mif3_,mif4_],alphaOlequ3bar[mif1_,mif2_,mif3_,mif4_],alphaWeinberg[mif1_,mif2_],alphaWeinbergbar[mif1_,mif2_]};
(*/// Translation between MMEFT and Warsaw naming conventions. ///*)
reempMMtoWarsaw:={Symbol[SymbolName[alphaWeinberg]]->Subscript[Symbol[SymbolName[wwC]], 5],Symbol[SymbolName[alphaOll]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ll]]],Symbol[SymbolName[alphaOqq1]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ qq1]]],Symbol[SymbolName[alphaOqq3]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ qq3]]],Symbol[SymbolName[alphaOlq1]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[lq1]]],Symbol[SymbolName[alphaOlq3]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[lq3]]],Symbol[SymbolName[alphaOee]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ee]]],Symbol[SymbolName[alphaOdd]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[dd]]],Symbol[SymbolName[alphaOuu]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[uu]]],Symbol[SymbolName[alphaOed]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ ed]]],Symbol[SymbolName[alphaOeu]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ eu]]],Symbol[SymbolName[alphaOud1]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ ud1]]],Symbol[SymbolName[alphaOud8]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ ud8]]],Symbol[SymbolName[alphaOle]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[le]]],Symbol[SymbolName[alphaOld]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ld]]],Symbol[SymbolName[alphaOlu]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[lu]]],Symbol[SymbolName[alphaOqe]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[qe]]],Symbol[SymbolName[alphaOqu1]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[qu1]]],Symbol[SymbolName[alphaOqu8]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[qu8]]],Symbol[SymbolName[alphaOqd1]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[qd1]]],Symbol[SymbolName[alphaOqd8]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[qd8]]],Symbol[SymbolName[alphaOledq]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ ledq]]],Symbol[SymbolName[alphaOquqd1]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ quqd1]]],Symbol[SymbolName[alphaOquqd8]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ quqd8]]],Symbol[SymbolName[alphaOlequ1]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[lequ1]]],Symbol[SymbolName[alphaOlequ3]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ lequ3]]],Symbol[SymbolName[alphaOduq]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ duq]]],Symbol[SymbolName[alphaOqqu]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[qqu]]],Symbol[SymbolName[alphaOqqq]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[qqq]]],Symbol[SymbolName[alphaOduu]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[duu]]],Symbol[SymbolName[alphaO3W]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[W]]],Symbol[SymbolName[alphaO3Wt]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ Wtil]]],Symbol[SymbolName[alphaO3G]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[G]]],Symbol[SymbolName[alphaO3Gt]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ Gtil]]],Symbol[SymbolName[alphaOH]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ \[Phi]]]],Symbol[SymbolName[alphaOHD]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ \[Phi]D]]],Symbol[SymbolName[alphaOHBox]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ \[Phi]Sq]]],Symbol[SymbolName[alphaOHB]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ \[Phi]B]]],Symbol[SymbolName[alphaOHBt]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ \[Phi]Btil]]],Symbol[SymbolName[alphaOHW]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ \[Phi]W]]],Symbol[SymbolName[alphaOHWt]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ \[Phi]Wtil]]],Symbol[SymbolName[alphaOHWB]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ \[Phi]WB]]],Symbol[SymbolName[alphaOHWBt]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[\[Phi]WBtil]]],Symbol[SymbolName[alphaOHG]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[\[Phi]G]]],Symbol[SymbolName[alphaOHGt]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[\[Phi]Gtil]]],Symbol[SymbolName[alphaOeH]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ e\[Phi]]]],Symbol[SymbolName[alphaOdH]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ d\[Phi]]]],Symbol[SymbolName[alphaOuH]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ u\[Phi]]]],Symbol[SymbolName[alphaOeB]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ eB]]],Symbol[SymbolName[alphaOeW]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ eW]]],Symbol[SymbolName[alphaOdB]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ dB]]],Symbol[SymbolName[alphaOuB]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[uB]]],Symbol[SymbolName[alphaOuW]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ uW]]],Symbol[SymbolName[alphaOdW]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[dW]]],Symbol[SymbolName[alphaOdG]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ dG]]],Symbol[SymbolName[alphaOuG]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ uG]]],Symbol[SymbolName[alphaOHl1]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[\[Phi]L1]]],Symbol[SymbolName[alphaOHl3]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ \[Phi]L3]]],Symbol[SymbolName[alphaOHq1]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ \[Phi]q1]]],Symbol[SymbolName[alphaOHq3]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ \[Phi]q3]]],Symbol[SymbolName[alphaOHe]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ \[Phi]e]]],Symbol[SymbolName[alphaOHd]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ \[Phi]d]]],Symbol[SymbolName[alphaOHu]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[\[Phi]u]]],Symbol[SymbolName[alphaOHud]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ \[Phi]ud]]],Symbol[SymbolName[alphaOlambda]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ \[Phi]4]]],Symbol[SymbolName[alphaOlambdad]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ y]]][Symbol[SymbolName[d]]],Symbol[SymbolName[alphaOlambdae]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ y]]][Symbol[SymbolName[e]]],Symbol[SymbolName[alphaOlambdau]]->Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ y]]][Symbol[SymbolName[u]]]};
replaceSMparamsMatchMakerEFT:={Symbol[SymbolName[g1]]->Subscript[g1,SM],Symbol[SymbolName[g2]]->Subscript[g2,SM],Symbol[SymbolName[g3]]->Subscript[g3,SM],
Symbol[SymbolName[yu]][a_,b_]:>y[u][a,b],Symbol[SymbolName[yubar]][a_,b_]:>Conjugate[y[u][a,b]],Symbol[SymbolName[yd]][a_,b_]:>y[d][a,b],Symbol[SymbolName[ydbar]][a_,b_]:>Conjugate[y[d][a,b]],Symbol[SymbolName[yl]][a_,b_]->y[e][a,b],
Symbol[SymbolName[ylbar]][a_,b_]:>Conjugate[y[e][a,b]],Symbol[SymbolName[lam]]->\[Lambda]\[Phi],Symbol[SymbolName[muH]]->I*Rationalize[mSM[H]/Sqrt[2.]]};
ewReemp:={Symbol[SymbolName[sW]]->Symbol[SymbolName[g1]]/Sqrt[Symbol[SymbolName[g2]]^2+Symbol[SymbolName[g1]]^2],Symbol[SymbolName[cW]]->Symbol[SymbolName[g2]]/Sqrt[Symbol[SymbolName[g2]]^2+Symbol[SymbolName[g1]]^2]};


(* ::Section::Closed:: *)
(*SMEFiT conventions*)


(*/// SMEFiT basis ///*)
requiredWCsmeftsimBasisNonEval:={{"WC SMEFiT","WC Warsaw"},{Symbol[SymbolName[wwC\[CurlyPhi]G]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[\[Phi]G]]]},{Symbol[SymbolName[wwC\[CurlyPhi]B]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[\[Phi]B]]]},{Symbol[SymbolName[wwC\[CurlyPhi]W]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[\[Phi]W]]]},{Symbol[SymbolName[wwC\[CurlyPhi]WB]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[\[Phi]WB]]]},{Symbol[SymbolName[wwC\[CurlyPhi]d]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[\[Phi]Sq]]]},{Symbol[SymbolName[wwC\[CurlyPhi]D]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[\[Phi]D]]]},{Symbol[SymbolName[wwCWWW]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[W]]]},{Symbol[SymbolName[wwC\[CurlyPhi]qm]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[\[Phi]q1]]][2,2]-Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[\[Phi]q3]]][2,2]},{Symbol[SymbolName[wwC\[CurlyPhi]Qm]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[\[Phi]q1]]][3,3]-Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[\[Phi]q3]]][3,3]},{Symbol[SymbolName[wwC\[CurlyPhi]q3]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[\[Phi]q3]]][2,2]},{Symbol[SymbolName[wwC\[CurlyPhi]Q3]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[\[Phi]q3]]][3,3]},{Symbol[SymbolName[wwC\[CurlyPhi]l11]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[\[Phi]L1]]][1,1]},{Symbol[SymbolName[wwC\[CurlyPhi]l12]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[\[Phi]L1]]][2,2]},{Symbol[SymbolName[wwC\[CurlyPhi]l13]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[\[Phi]L1]]][3,3]},{Symbol[SymbolName[wwC\[CurlyPhi]l31]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[\[Phi]L3]]][1,1]},{Symbol[SymbolName[wwC\[CurlyPhi]l32]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[\[Phi]L3]]][2,2]},{Symbol[SymbolName[wwC\[CurlyPhi]l33]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[\[Phi]L3]]][3,3]},{Symbol[SymbolName[wwC\[CurlyPhi]ui]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[\[Phi]u]]][2,2]},{Symbol[SymbolName[wwC\[CurlyPhi]di]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[\[Phi]d]]][2,2]},{Symbol[SymbolName[wwC\[CurlyPhi]t]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[\[Phi]u]]][3,3]},{Symbol[SymbolName[wwC\[CurlyPhi]e]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[\[Phi]e]]][1,1]},{Symbol[SymbolName[wwC\[CurlyPhi]\[Mu]]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[\[Phi]e]]][2,2]},{Symbol[SymbolName[wwC\[CurlyPhi]\[Tau]]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[\[Phi]e]]][3,3]},{Symbol[SymbolName[wwCQq18]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[qq1]]][1,3,3,1]+3Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[qq3]]][1,3,3,1]},{Symbol[SymbolName[wwCQq11]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[qq1]]][1,1,3,3]+(1/6)Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[qq1]]][1,3,3,1]+(1/2)Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[qq3]]][1,3,3,1]},{Symbol[SymbolName[wwCQq38]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[qq1]]][1,3,3,1]-Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[qq3]]][1,3,3,1]},{Symbol[SymbolName[wwCQq31]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[qq3]]][1,1,3,3]+(1/6)Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[qq1]]][1,3,3,1]-(1/6)Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[qq3]]][1,3,3,1]},{Symbol[SymbolName[wwCtq8]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[qu8]]][1,1,3,3]},{Symbol[SymbolName[wwCtq1]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[qu1]]][1,1,3,3]},{Symbol[SymbolName[wwCtu8]],2*Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[uu]]][1,3,3,1]},{Symbol[SymbolName[wwCtu1]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[uu]]][1,1,3,3]+(1/3)Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[uu]]][1,3,3,1]},{Symbol[SymbolName[wwCQu8]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[qu8]]][3,3,1,1]},{Symbol[SymbolName[wwCQu1]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[qu1]]][3,3,1,1]},{Symbol[SymbolName[wwCtd8]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ud8]]][3,3,3,3]},{Symbol[SymbolName[wwCtd1]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ud1]]][3,3,3,3]},{Symbol[SymbolName[wwCQd8]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[qd8]]][3,3,3,3]},{Symbol[SymbolName[wwCQd1]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[qd1]]][3,3,3,3]},{Symbol[SymbolName[wwCQQ1]],2Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[qq1]]][3,3,3,3]-(2/3)Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[qq3]]][3,3,3,3]},{Symbol[SymbolName[wwCQQ8]],8Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[qq3]]][3,3,3,3]},{Symbol[SymbolName[wwCQt1]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[qu1]]][3,3,3,3]},{Symbol[SymbolName[wwCQt8]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[qu8]]][3,3,3,3]},{Symbol[SymbolName[wwCtt1]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[uu]]][3,3,3,3]},{Symbol[SymbolName[wwCll]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[ll]]][1,2,2,1]},{Symbol[SymbolName[wwCb\[CurlyPhi]]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[d\[Phi]]]][3,3]},{Symbol[SymbolName[wwCt\[CurlyPhi]]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[u\[Phi]]]][3,3]},{Symbol[SymbolName[wwCtG]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[uG]]][3,3]},{Symbol[SymbolName[wwCc\[CurlyPhi]]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[u\[Phi]]]][2,2]},{Symbol[SymbolName[wwC\[Tau]\[CurlyPhi]]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[e\[Phi]]]][3,3]},{Symbol[SymbolName[wwCtW]],Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[uW]]][3,3]},{Symbol[SymbolName[wwCtZ]],-Symbol[SymbolName[sW]]*Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[uB]]][3,3]+Symbol[SymbolName[cW]]*Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[uB]]][3,3]}};
vanishBviolation={Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[duq]]]->0,Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[qqu]]]->0,Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[qqq]]]->0,Subscript[Symbol[SymbolName[wwC]],Symbol[SymbolName[duu]]]->0};


simplifyUVcoupNames[UVcoups_]:=Block[{ret},
If[Length[UVcoups]>0,
ret=Flatten[Table[{ToExpression[ToString[UVcoups[[j]]]<>"[a_]:>ToExpression[\""<>ToString[UVcoups[[j]]]<>"\"<>ToString[a]]"],ToExpression[ToString[UVcoups[[j]]]<>"[a_,b_]:>ToExpression[\""<>ToString[UVcoups[[j]]]<>"\"<>ToString[a]<>ToString[b]]"],ToExpression[ToString[UVcoups[[j]]]<>"[a_,b_,c_]:>ToExpression[\""<>ToString[UVcoups[[j]]]<>"\"<>ToString[a]<>ToString[b]<>ToString[c]]"],ToExpression[ToString[UVcoups[[j]]]<>"[a_,b_,c_,d_]:>ToExpression[\""<>ToString[UVcoups[[j]]]<>"\"<>ToString[a]<>ToString[b]<>ToString[c]<>ToString[d]]"],ToExpression[ToString[UVcoups[[j]]]<>"[a_,b_,c_,d_,e_]:>ToExpression[\""<>ToString[UVcoups[[j]]]<>"\"<>ToString[a]<>ToString[b]<>ToString[c]<>ToString[d]<>ToString[e]]"]},{j,1,Length[UVcoups]}]];
,ret={a_[b_]:>ToExpression[ToString[a]<>ToString[b]]}];
ret]


(* ::Section:: *)
(*SM numerical inputs*)


(* ::Subsection::Closed:: *)
(*Gauge parameters*)


(*/// SM Gauge parameters ///*)
\[Alpha]Strong:=Rationalize[0.1179]; (*From PDG, at mZ*)
\[Delta]\[Alpha]Strong:=Rationalize[9*10^(-4)];
sin2Weinberg:=Rationalize[0.23121] ;(*From PDG, at mZ, MSbar*)
\[Delta]sin2Weinberg:=Rationalize[4*10^(-5)];
GFermi:=Rationalize[1.1663787*10^(-5)];(*From PDG, in GeV^-2*)
\[Delta]GFermi:=Rationalize[0.0000006*10^(-5)];
mSM[W]:=Rationalize[0.080379]; (*From PDG, in TeV*)
\[Delta]mSM[W]:=Rationalize[12*10^(-6)];(*From PDG, in TeV*)
mSM[Z]:=Rationalize[0.0911876];(*From PDG, in TeV*)
\[Delta]mSM[Z]:=Rationalize[21*10^(-7)];
mSM[H]:=Rationalize[0.12525];(*From PDG, in TeV*)
\[Delta]mSM[H]:=Rationalize[1.7*10^(-4)];
Subscript[g2,SM]:=Rationalize[Sqrt[8/Sqrt[2]*(10^(3)*mSM[W])^2*GFermi]];
Subscript[g1,SM]:=Rationalize[Subscript[g2,SM]*Sqrt[sin2Weinberg/(1-sin2Weinberg)]];
Subscript[g3,SM]:=Rationalize[Sqrt[4Pi \[Alpha]Strong]];
vSM=Rationalize[0.24622];
\[Lambda]\[Phi]=Rationalize[(1/2)*(mSM[H]/vSM)^2];


(* ::Subsection:: *)
(*Masses and Yukawas*)


(*/// SM masses and Yukawas ///*)
(*/// Option for mass and Yukawa flavour assumption.
"SMEFiT3" : \[Tau], bottom and top Yukawas and masses to their SM values.
"SMEFiTop" : only top Yukawa and mass to their SM value, all the rest to zero. 
"SMEFiTcharm: \[Tau], bottom, charm and top Yukawas and masses to their SM values.///*)
flavourOption="SMEFiT3";
mSM[\[Tau]]:=Piecewise[{{Rationalize[0.00178],flavourOption=="SMEFiT3"},{0,flavourOption=="SMEFiTop"}},Rationalize[0.00178]];
mSM[\[Mu]]:=0;
mSM[e]:=0;
mSM[W]:=Rationalize[0.080379];
mSM[Z]:=Rationalize[0.0911876];
mSM[h]:=Rationalize[0.12525];
mSM[t]:=Rationalize[0.17276];
mSM[b]:=Piecewise[{{Rationalize[0.00418],flavourOption=="SMEFiT3"},{0,flavourOption=="SMEFiTop"}},Rationalize[0.00418]];
mSM[c]:=Piecewise[{{Rationalize[0.00127],flavourOption=="SMEFiTcharm"}},0];
mSM[u]:=0;
mSM[d]:=0;
mSM[s]:=0;
y[e][i_,j_]:=Piecewise[{{mSM[e]*Sqrt[2]/vSM,i==1&&j==1},{mSM[\[Mu]]*Sqrt[2]/vSM,i==2&&j==2},{mSM[\[Tau]]*Sqrt[2]/vSM,i==3&&j==3}},0];
y[d][i_,j_]:=Piecewise[{{mSM[d]*Sqrt[2]/vSM,i==1&&j==1},{mSM[s]*Sqrt[2]/vSM,i==2&&j==2},{mSM[b]*Sqrt[2]/vSM,i==3&&j==3}},0];
y[u][i_,j_]:=Piecewise[{{mSM[u]*Sqrt[2]/vSM,i==1&&j==1},{mSM[c]*Sqrt[2]/vSM,i==2&&j==2},{mSM[t]*Sqrt[2]/vSM,i==3&&j==3}},0];


(* ::Section:: *)
(*Dictionary and invariant computing*)


(* ::Subsection:: *)
(*Dictionary*)


dictionaryToPrint[matchResFile_]:=Module[{file,uvparams,reempUVreal,reempMassDegen,dictProv},file=Get[matchResFile];
uvparams=parametersListFromMatchingResult[matchResFile];
reempUVreal=Table[ToExpression[ToString[j]<>"bar"]->j,{j,uvparams[[2]]}];
reempMassDegen=Table[j->Symbol[SymbolName[m]],{j,uvparams[[1]]}];
dictProv=requiredWCsmeftsimBasisNonEval[[2;;-1]]/.(file[[3]]/.reempMMtoWarsaw/.vanishBviolation)/.file[[4]];
dictProv=dictProv/.renormReemp/.leviCivitaConvention/.{Log[a_]:>0}/.{Symbol[SymbolName[onelooporder]]->1};
dictProv=dictProv/.reempUVreal/.reempMassDegen/.ewReemp/.replaceSMparamsMatchMakerEFT[[1;;3]];
dictProv=EinsteinSum[dictProv];(*ParallelTable[With[{dictio=Symbol[SymbolName[dictProv]]},{Symbol[SymbolName[dictio]][[l,1]],EinsteinSum[Symbol[SymbolName[dictio]][[l,2]]]}],{l,1,Length[dictProv]}]*)
dictProv=dictProv/.reempSquaredDeltasEinstein/.replaceSMparamsMatchMakerEFT[[4;;-1]];
(*Print[dictProv];*)
dictProv];
dictionaryToPrintMultiPart[matchResFile_]:=Module[{file,uvparams,reempUVreal,reempMassNoDegen,dictProv},file=Get[matchResFile];
uvparams=parametersListFromMatchingResult[matchResFile];
reempUVreal=Table[ToExpression[ToString[j]<>"bar"]->j,{j,uvparams[[2]]}];
reempMassNoDegen=Table[uvparams[[1]][[j]]->Symbol[SymbolName[m]<>ToString[j]],{j,1,Length[uvparams[[1]]]}];
dictProv=requiredWCsmeftsimBasisNonEval[[2;;-1]]/.(file[[3]]/.reempMMtoWarsaw/.vanishBviolation)/.file[[4]];
dictProv=dictProv/.renormReemp/.leviCivitaConvention/.{Log[a_]:>0}/.{Symbol[SymbolName[onelooporder]]->1};
dictProv=dictProv/.reempUVreal/.reempMassNoDegen/.ewReemp/.replaceSMparamsMatchMakerEFT[[1;;3]];
dictProv=EinsteinSum[dictProv];
dictProv=dictProv/.reempSquaredDeltasEinstein/.replaceSMparamsMatchMakerEFT[[4;;-1]];
{dictProv,uvparams[[1]]}];


(* ::Subsection:: *)
(*Invariant building*)


(*/// Set of functions that build the UV Invariants ///*)
analyseMixing[]:=Module[{indAux,entangledPowers,numMixing,positionMixedCoup,leadPowerEntang},
For[indAux=1,indAux<=Length[threePos],indAux++,
(*/// Number of other UV couplings appearing in the same monomial. ///*)
entangledPowers=DeleteCases[Delete[reducedPowerTable[[indAux]],indInvar],0];
numMixing=Length[entangledPowers];
(*/// If there's no other UV coupling appearing in that monomial, check the following. ///*)
If[numMixing==0,Continue[];];
(*/// This code is not prepared for more than 2 UV couplings in the same monomial. ///*)
If[numMixing>1,Print["WARNING: This algorithm was prepared thinking of at most 2 UV couplings appearing in the same monomial.\nA case outside this assumption has been found.\nThis monomial will be neglected in the invariant building.\nCorrect behaviour not guaranteed."];
Continue[];];
(*/// The following should be executed only in the case of mixing with one another UV coupling. ///*)
(*/// Identify which UV coupling is the one that appears mixed. ///*)
positionMixedCoup=Position[reducedPowerTable[[indAux]],entangledPowers[[1]]][[1,1]];
(*/// If the mixed UV coupling is one that will be checked later, let's pospone the problem. ///*)
If[positionMixedCoup>=indInvar,Continue[];];
(*/// If the mixed UV coupling was already checked, let's see to which sign we can be sensitive to. ///*)
(*If[positionMixedCoup<indInvar,*)
(*/// If we're sensitive to the sign of the entangled coupling, we then are sensitive to the sign of varsUV[[indInvar]]. ///*)
If[MemberQ[listInvars,varsUV[[positionMixedCoup]]],AppendTo[listInvars,varsUV[[indInvar]]];indInvar+=1;Break[];];
(*/// If not, check what's the leading power that the other coupling appears with. ///*)
leadPowerEntang=Max[powerTable[[;;,positionMixedCoup]]];
(*/// If we're not sensitive to the sign of the entangled coupling, we are only sensitive to the sign of the product. ///*)
(*/// We expect better sensitivity to those couplings appearing with smaller powers, so I use that in the denominator. ///*)
If[leadPowerEntang<=leadPower&&(MemberQ[listInvars,Abs[varsUV[[positionMixedCoup]]]]||MemberQ[listInvars,varsUV[[positionMixedCoup]]*_]),
AppendTo[listInvars,varsUV[[indInvar]]*varsUV[[positionMixedCoup]]/Abs[varsUV[[positionMixedCoup]]]];indInvar+=1;Break[];];
If[leadPowerEntang>leadPower&&MemberQ[listInvars,Abs[varsUV[[positionMixedCoup]]]],
AppendTo[listInvars,varsUV[[indInvar]]*varsUV[[positionMixedCoup]]/Abs[varsUV[[indInvar]]]];
listInvars=DeleteCases[listInvars,Abs[varsUV[[positionMixedCoup]]]];
If[indAux==Length[threePos],AppendTo[listInvars,Abs[varsUV[[indInvar]]]];
indInvar+=1;Break[];];];];]
(*/// Function that builds the invariants. ///*)
invariantBuilder[monoBase_,nonZeroLIWCsMonoBase_]:=Block[{varsUV,powerTable,listInvars,indInvar,leadPower,oddPowers,lowestExpo,indAux,threePos,reducedPowerTable,entangledPowers,numMixing,positionMixedCoup,leadPowerEntang,indInvarBefore,mixingPos,mixingGrid,mixingNumber,posMixing,indMix,posToReplace,posLeadPower,reducedMixingTable,powerMixing,subLeadingInvar,cubicInvar,reducedWCsMonoBase,liWCsUVcoupBase,numOfSensUV,liWCsMonoBase,numVarsUVorig,listDummyWCs,solWCsUVs,varsUVinWCs,redPowTablePlus},
(*/// Get the UV couplings that appear in the invariants. ///*)
varsUV=DeleteDuplicates[Variables[monoBase]];
numVarsUVorig=Length[varsUV];
Print[monoBase];
(*/// Create table with the power of each UV coupling in each invariant. Element (i,j): exponent of the j-th UV coupling in the i-th invariant. ///*)
powerTable=Table[Exponent[monoBase[[i]],varsUV[[j]]],{i,1,Length[monoBase]},{j,1,Length[varsUV]}];
listInvars={};(*/// List to store the invariants. ///*)
(*/// First, we have to check if we have enough LI WCs to be sensitive to all UV couplings or if we will be sensitive to only certain LC of them. ///*)
(*/// If there as many monomials as LI WCs, this check has to be done directly on the monomials. ///*)
If[Length[monoBase]==Length[nonZeroLIWCsMonoBase],
numOfSensUV=MatrixRank[powerTable];
,
(*/// If not, on the LI WCs ///*)
(*///I have to implement the following: use row reduce to identify non-trivial LC of monomials,
then identify which WCs are proportional to those LCs. Set those apart and build trivial invariants from them.
Do the normal procedure for the remaining WCs (recursion?) and add the trivial invariants. Check that they offer something different. ///*)
liWCsUVcoupBase=Unitize[Abs[nonZeroLIWCsMonoBase/.{Symbol[SymbolName[m]]->1}] . powerTable];
numOfSensUV=MatrixRank[liWCsUVcoupBase];
];
liWCsMonoBase=nonZeroLIWCsMonoBase;
(*/// If the rank of liWCsUVcoupBase is smaller than the number of UV couplings, we won't be sensitive to all of them. ///*)
If[numOfSensUV<Length[varsUV],
(*/// Create function to select which LCs of UV monomials we'll be sensitive to. ///*)
Module[{c,ifUVonUV,nonSolvableUV,involvedWCs,listEasyInvars,idNonSolvUVs,monoToEliminate,rowReducedLIWCsMonoBase,lincombmono,invarWCs,
\[Alpha],invertibleWCs,invertWCsMonoBase,removableMono,invertMonoBase,\[Beta],rowreducedPowerTable,prodUVcoup,indistMono,posIndistMono,checkTable,
distinguishableMono,distingMonoExplicit,wcsMonoBase,distingWCs},
If[Length[monoBase]!=Length[nonZeroLIWCsMonoBase],
rowReducedLIWCsMonoBase=RowReduce[nonZeroLIWCsMonoBase];
(*/// List of non-trivial linear comb of UV monomials that we will be sensitive to. ///*)
lincombmono=Extract[rowReducedLIWCsMonoBase,Position[Unitize[rowReducedLIWCsMonoBase],n_ /; Total[n]>1]];
(*/// Find which WCs will give you those linear combinations of UV monomials. ///*)
invarWCs=Table[\[Alpha][l],{l,1,Length[nonZeroLIWCsMonoBase]}]/.Table[Solve[Sum[\[Alpha][k]*nonZeroLIWCsMonoBase[[k]],{k,1,Length[nonZeroLIWCsMonoBase]}]==lincombmono[[j]],Table[\[Alpha][l],{l,1,Length[nonZeroLIWCsMonoBase]}]],{j,1,Length[lincombmono]}][[;;,1]];
invertibleWCs=NullSpace[invarWCs];
invertWCsMonoBase=Table[Sum[invertibleWCs[[-k,l]]*nonZeroLIWCsMonoBase[[l]],{l,1,Length[nonZeroLIWCsMonoBase]}],{k,1,Length[invertibleWCs]}];
removableMono=Position[Transpose[invertWCsMonoBase],n_/;n . Conjugate[n]==0,{1}];
invertWCsMonoBase=Transpose[Delete[Transpose[invertWCsMonoBase],removableMono]];
invertMonoBase=Delete[monoBase,removableMono];
listEasyInvars=invarWCs . nonZeroLIWCsMonoBase . monoBase;
listInvars=Join[listEasyInvars,invariantBuilder[invertMonoBase,invertWCsMonoBase]];
Goto[returnpoint],
(*/// Case of Length[monoBase]==Length[nonZeroLIWCsMonoBase] ///*)
(*/// This is the case I still have to sort out ///*)
rowreducedPowerTable=RowReduce[powerTable];
prodUVcoup=Extract[rowreducedPowerTable,Position[Unitize[rowreducedPowerTable],n_/;Total[n]>1]];
(*/// Find which monomials will give you those products of UV couplings. ///*)
indistMono=(Table[\[Beta][l],{l,1,Length[powerTable]}]/.Table[Quiet[Solve[Sum[\[Beta][k]*powerTable[[k]],{k,1,Length[powerTable]}]==prodUVcoup[[j]],Table[\[Beta][l],{l,1,Length[powerTable]}]]],{j,1,Length[prodUVcoup]}][[;;,1]])/.Table[\[Beta][l]->0,{l,1,Length[powerTable]}];
(*///The last replacement above accounts for possible monomials that are multiplicatively related to others.///*)
(*/// At tree-level, we don't expect the indistinguishable monomial to appear mixed with others. That could occur at 1-loop level though. ///*)
posIndistMono=Position[indistMono,1,2][[;;,2]];
checkTable=Table[Block[{ret,sub},sub=powerTable[[k]]-powerTable[[posIndistMono[[l]]]];If[Total[Unitize[sub]]==0||Count[Negative[sub],True]>0,ret="OK","NO"];ret],{k,1,Length[powerTable]},{l,1,Length[posIndistMono]}];
If[Count[Flatten[checkTable],"NO"]==0,
distinguishableMono=NullSpace[indistMono];
distingMonoExplicit=Table[Product[varsUV[[i]]^(Sum[distinguishableMono[[-k,l]]powerTable[[l,i]],{l,1,Length[powerTable]}]),{i,1,Length[varsUV]}],{k,1,Length[distinguishableMono]}];
(*wcsMonoBase=Inverse[nonZeroLIWCsMonoBase].Table[dwc[i],{i,1,Length[nonZeroLIWCsMonoBase]}];*)
listInvars=Join[Table[Product[varsUV[[i]]^(Sum[indistMono[[k,l]]powerTable[[l,i]],{l,1,Length[powerTable]}]),{i,1,Length[varsUV]}],{k,1,Length[indistMono]}],invariantBuilder[distingMonoExplicit,IdentityMatrix[Length[distingMonoExplicit]]]];
Goto[returnpoint];
(*{wcsMonoBase,reducedNonZeroLIWCsMonoBase}=Block[{posTodel},posToDel=Table[{posIndistMono[[i]]},{i,1,Length[posIndistMono]}];{Delete[wcsMonoBase,Table[{posIndistMono[[i]]},{i,1,Length[posIndistMono]}]],}];
*)
(*Need to identify the WC related to the indisting Mono and eliminate them*)
(*nonZeroLIWCsExplicit=Table[Sum[nonZeroLIWCsMonoBase[[k,l]]
Table[Coefficient[(nonZeroLIWCs[[j,2]]-listNonZeroLIWCsIndepTerm[[j]])(*/.{m\[Rule]1}*),monoBase[[i]]],{j,1,Length[nonZeroLIWCs]},{i,1,Length[monoBase]}]
*)
,
Print["WARNING: This case is expected only from 1-loop matching results.\n
The current version of the code is not prepared for them.\n
Future releases will implement the solution to this case.\n
As a provisional solution, we return all the UV variables 
as invariants.\n
The user should check carefully since it's expected that some of the 
UV variables can not be distinguished."];
listInvars=varsUV;
Goto[returnpoint];
];];];
];
(*/// Start building invariants. There should be at most one invariant per LI WCs. There could be less if for example 2 LI WCs are LI because one has a quadratic dependence on an UV coupling and the other has one that is quartic. The maximum number of invariants is the minimum between the number of LI WCs and the number of UV couplings. ///*)
(*/// Adapt the number below depending on the output of the previous section. ///*)
indInvar=1; (*/// We will loop over each UV coupling, since each of them is a possible invariant. In fact, ideally, invarsUV=varsUV. ///*)
While[Length[listInvars]<Min[Length[nonZeroLIWCsMonoBase[[;;,1]]],numVarsUVorig]&&indInvar<=Length[varsUV],
(*/// Find the highest exponent with which the UV coupling varsUV[[indInvar]] appears. ///*)
leadPower=Max[powerTable[[;;,indInvar]]];
(*/// Find with which odd (if any) exponents varsUV[[indInvar]] appears. ///*)
oddPowers=Select[powerTable[[;;,indInvar]],OddQ];
(*/// If this UV coefficient only appears with even powers, the invariant will be naturally Abs[varsUV[[indInvar]]] and there's nothing else todo. If later we discover that one of its appearances is together an odd power of another coupling, we can retroactively add the sign of the product to the invariant. ///*)
If[Length[oddPowers]==0,AppendTo[listInvars,Abs[varsUV[[indInvar]]]];indInvar+=1;Continue[];];
(*/// Print warning and add the UV coupling as invariant if the leading power is bigger than 4 (and odd). ///*)
If[leadPower>4,Print["WARNING: This algorithm was prepared thinking of UV couplings appearing with powers up-to-4 or all-even.\nA case outside this assumption has been found.\nThe UV coupling is considered an invariant as default.\nCorrect behaviour not guaranteed."];
AppendTo[listInvars,varsUV[[indInvar]]];indInvar+=1;Continue[];];
(*/// Find lowest non-vanishing exponent with which this UV coupling appears. ///*)
lowestExpo=Min[DeleteCases[powerTable[[;;,indInvar]],0]];
(*/// If it only appears with powers 4, 3 and 2, the sensitivity to the sign will probably be negligible. ///*)
If[leadPower==4&&lowestExpo==2,AppendTo[listInvars,Abs[varsUV[[indInvar]]]];indInvar+=1;Continue[];];
(*/// If it only appears with powers 4 and 3, there might be sensitivity to the sign of the coupling or a product. ///*)
(*/// The case of powers 4 and 3 turns out to be equal to analyse than the one of powers 2 and 1. ///*)
If[(leadPower==4&&(lowestExpo==3||lowestExpo==1))||(leadPower==2&&(lowestExpo==1)),
(*/// Find in which monomials the couplings appear with the lowest exponent (originally developed for the value 3, hence the name). ///*)
threePos=Flatten[Position[powerTable[[;;,indInvar]],lowestExpo]];
(*/// Take only the decomposition of those monomials. ///*)
reducedPowerTable=powerTable[[threePos,;;]];
indInvarBefore=indInvar; (*/// Save the indInvar value to see if the next step adds or not an invariant. ///*)
redPowTablePlus=Transpose[Delete[Transpose[reducedPowerTable],indInvar]];
If[Length[DeleteDuplicates[Flatten[redPowTablePlus]]]>0,
(*/// Check the monomials one by one to see if there's any interplay with other couplings. External function. ///*)
analyseMixing[];
(*/// Once checked all the possible mixings, we need to see if the previous step added or not an invariant. If so, go to next UV coupling.///*)
(*/// If not, add the UV coupling as invariant (do not assume sign sensitivity) and go to next coupling. ///*)
If[indInvar==indInvarBefore,AppendTo[listInvars,Abs[varsUV[[indInvar]]]];
indInvar+=1;];,
AppendTo[listInvars,varsUV[[indInvar]]];
indInvar+=1;];
Continue[];
];(*/// End of the cases of 4-(3 or 1) and 2-1. ///*)
(*/// Cases with leading power=1 ///*)
If[leadPower==1,
If[indInvar==1,AppendTo[listInvars,Abs[varsUV[[indInvar]]]];indInvar+=1;Continue[];];
(*/// Identify which monomials are the ones generating the mixing. ///*)
mixingPos=Flatten[Position[powerTable[[;;,indInvar]],1]];
(*/// Take the sub-matrix of the decomposition corresponding to those monomials and to the UV couplings analysed before. Mixing with couplings that will appear later will be analysed later. ///*)
reducedPowerTable=powerTable[[mixingPos,1;;(indInvar-1)]];
(*/// Count how many UV couplings are involved in the mixing. ///*)
mixingGrid=Unitize[Table[Total[Unitize[reducedPowerTable[[;;,i]]]],{i,1,indInvar-1}]];
mixingNumber=Total[mixingGrid];
(*/// If there's no mixing, nothing to do. Just add the absolute value of this UV coupling as invariant and mixing with couplings in positions ahead will be treated later. ///*)
If[mixingNumber==0,AppendTo[listInvars,Abs[varsUV[[indInvar]]]];indInvar+=1;Continue[];];
(*/// If there's only one coupling involved in the mixing, find which one is, and add the invariant that is absolute value of varsUV[[indInvar]]*sign of the product if the power of the other is odd.///*)
If[mixingNumber==1,posMixing=Position[mixingGrid,1][[1,1]];powerMixing=Min[DeleteCases[DeleteDuplicates[reducedPowerTable[[;;,posMixing]]],0]];
If[OddQ[powerMixing],AppendTo[listInvars,varsUV[[indInvar]]*varsUV[[posMixing]]/Abs[varsUV[[posMixing]]]];indInvar+=1;Continue[];];
AppendTo[listInvars,varsUV[[indInvar]]];indInvar+=1;Continue[];];
(*/// If there's more than one coupling in the mix, treat the first as you did in the previous case and for the rest, assume you've assumed sign-sensitivity and add that's sensitivity to the product. ///*)
If[mixingNumber>1,posMixing=Position[mixingGrid,1][[;;,1]];AppendTo[listInvars,varsUV[[indInvar]]*varsUV[[posMixing[[1]]]]/Abs[varsUV[[posMixing[[1]]]]]];indInvar+=1;
For[indMix=2,indMix<=mixingNumber,indMix++,If[MemberQ[listInvars,varsUV[[posMixing[[indMix]]]]],posToReplace=Position[listInvars,varsUV[[posMixing[[indMix]]]]][[1,1]];];
If[MemberQ[listInvars,Abs[varsUV[[posMixing[[indMix]]]]]],posToReplace=Position[listInvars,Abs[varsUV[[posMixing[[indMix]]]]]][[1,1]];];If[NumericQ[posToReplace],listInvars[[posToReplace]]=varsUV[[posMixing[[indMix]]]]*varsUV[[indInvar]]/Abs[varsUV[[indInvar]]];];];];
];
(*/// Cases with leading power =3 ///*)
If[leadPower==3,
(*/// If three is the only power that appears, I have sign-sensitivity. ///*)
If[FreeQ[powerTable[[;;,indInvar]],2]&&FreeQ[powerTable[[;;,indInvar]],1],AppendTo[listInvars,varsUV[[indInvar]]];indInvar+=1;Continue[];];
(*/// If the UV coupling can be determined from a system of equations of different orders, one can expect only one common solution and hence sign sensitivity. ///*)
lowestExpo=Min[DeleteCases[powerTable[[;;,indInvar]],0]];
cubicInvar=Position[powerTable[[;;,indInvar]],3][[;;,1]];
If[lowestExpo<=2,subLeadingInvar=Position[powerTable[[;;,indInvar]],2][[;;,1]];];
If[lowestExpo==1,subLeadingInvar=Join[subLeadingInvar,Position[powerTable[[;;,indInvar]],1][[;;,1]]];];
reducedWCsMonoBase=Select[liWCsMonoBase[[;;,Join[cubicInvar,subLeadingInvar]]],(Total[#]!=0)&];
If[Length[reducedWCsMonoBase]>1,AppendTo[listInvars,varsUV[[indInvar]]];indInvar+=1;
Continue[];];
(*/// If we only have a cubic equation, the situation is rather tricky. ///*)
(*/// If the lowest exponent is 2, we have to see how the power 3 appears. Assume that all monomials with total UV powers bigger than 2 are suppressed by loop factors and/or SM couplings. ///*)
If[lowestExpo==2,
posLeadPower=Position[powerTable[[;;,indInvar]],3][[1,1]];
(*/// If the monomial with cubic power mixes it with another UV coupling already analysed, assume sensitivity to the product sign. ///*)
If[Total[Abs[powerTable[[posLeadPower]]]]>3,mixingPos=Position[powerTable[[posLeadPower]],1][[1,1]];If[mixingPos<indInvar,AppendTo[listInvars,varsUV[[indInvar]]*varsUV[[mixingPos]]/Abs[varsUV[[mixingPos]]]];indInvar+=1;Continue[];];];
(*/// If not, assume sign sensitivity. ///*)
AppendTo[listInvars,varsUV[[indInvar]]];
indInvar+=1;
Continue[];];
If[lowestExpo==1&&indInvar>1,posMixing=Position[powerTable[[;;,indInvar]],1][[;;,1]];
reducedMixingTable=Select[powerTable[[posMixing,1;;(indInvar-1)]],_?(Total[#]!=0)&];
(*/// If there are several monomials inducing mixing, take the first. ///*)
If[Length[reducedMixingTable]>0,
mixingPos=Position[reducedMixingTable,1][[1,2]];
AppendTo[listInvars,varsUV[[indInvar]]*varsUV[[mixingPos]]/Abs[varsUV[[mixingPos]]]];indInvar+=1;Continue[];];];
AppendTo[listInvars,varsUV[[indInvar]]];
indInvar+=1;
Continue[];];
];
(*/// Return invariant list. ///*)
Label[returnpoint];
listInvars];
inverRelUVGen[nonZeroliwcs_,monoBase_]:=Module[{inverRelUV,avoidZeroSol,varsUV,indexNonZeroliwcs,nonZeroLIWCsMonoBase,monoWCsBase,tabMultRel,findMultRel,listMultRel,\[Alpha],varsMultRel,relExp,multRelWCs,flagMultRel,WCstoElimMult,indElim,inspectRow,posToElim,flagElimCoeff,rowReduced,lowestExp,posLowestExp,wcToElim,dictioFinal,dictioFinalFull,reempNonZeroLIWCs},
inverRelUV={};
(*/// This function takes the list of LI WCs and the base of monomials as input. ///*)
varsUV=DeleteCases[Variables[nonZeroliwcs[[;;,2]]],Symbol[SymbolName[m]]];
If[Length[nonZeroliwcs]>1,
(*/// The problem is particularly difficult if there's more than 1 non-zero LI WC ///*)
indexNonZeroliwcs=Table[k,{k,1,Length[nonZeroliwcs]}];(*/// Enumerates the non-zero LI WCs ///*)
(*/// Table with the decomposition of the non-zero LI WCs in the base of monomials. ///*)
nonZeroLIWCsMonoBase=Table[Coefficient[Symbol[SymbolName[m]]^2*nonZeroliwcs[[j,2]],monoBase[[i]]],{j,1,Length[nonZeroliwcs]},{i,1,Length[monoBase]}];
(*// Rotate to a base of pseudo-WCs that agree with the monomials//*)
If[Length[monoBase]==Length[nonZeroliwcs],
monoWCsBase=Inverse[nonZeroLIWCsMonoBase] . nonZeroliwcs[[;;,1]];,
Print["WARNING: The base of LI WCs doesn't match in dimensions the one of monomials, hence the rotation can't be done properly."]];
(*// Part that detects additional non-linear relations among WCs //*)
tabMultRel=Table[Exponent[monoBase[[i]],varsUV[[j]]],{i,1,Length[monoBase]},{j,1,Length[varsUV]}];
If[MatrixRank[tabMultRel]<Length[monoBase],
findMultRel=Quiet[Solve[tabMultRel[[1]]*0==Sum[\[Alpha][j]*tabMultRel[[j]],{j,1,Length[tabMultRel]}],Table[\[Alpha][k],{k,1,Length[tabMultRel]}]]];
listMultRel=Table[\[Alpha][i],{i,1,Length[tabMultRel]}]/.findMultRel;
varsMultRel=Variables[listMultRel];
relExp=Flatten[Table[listMultRel/.Table[varsMultRel[[i]]->If[i==j,1,0],{i,1,Length[varsMultRel]}],{j,1,Length[varsMultRel]}],1];
multRelWCs=Table[Product[monoWCsBase[[i]]^(relExp[[1,i]]),{i,1,Length[monoWCsBase]}],{i,1,Length[relExp]}];
flagMultRel=1;,flagMultRel=0;];
(*// Algorithm to pick WCs to eliminate, i.e. that will be dependent quantities, from the multiplicative relations. //*)
WCstoElimMult={};
If[flagMultRel==1,
For[indElim=1,indElim<=Length[relExp],indElim++,
inspectRow=relExp[[-indElim]];
posToElim={};
flagElimCoeff=0;
While[flagElimCoeff==0&&Length[posToElim]<Length[inspectRow],
rowReduced=Delete[inspectRow,posToElim];
lowestExp=findLowestExponent[rowReduced];
posLowestExp=Position[inspectRow,lowestExp][[1,1]];
wcToElim=monoWCsBase[[posLowestExp]];
If[MemberQ[WCstoElimMult,wcToElim],
AppendTo[posToElim,posLowestExp];,
AppendTo[WCstoElimMult,wcToElim];
flagElimCoeff=1;];];];];
(*// Finding the solutions for the UV couplings in terms of the WCs. //*)
dictioFinal=Select[monoWCsBase,(!MemberQ[WCstoElimMult,#])&];
reempNonZeroLIWCs=Table[nonZeroliwcs[[i,1]]->nonZeroliwcs[[i,2]],{i,1,Length[nonZeroliwcs]}];
dictioFinalFull=Table[{dictioFinal[[i]],dictioFinal[[i]]/.reempNonZeroLIWCs},{i,1,Length[dictioFinal]}];
inverRelUV=Quiet[Solve[Join[Table[dictioFinalFull[[i,1]]==dictioFinalFull[[i,2]],{i,1,Length[dictioFinalFull]}]],varsUV]];
,
(*///Computing the relations for the case of only 1 non-zero WC///*)
(*///If there's only one UV variable, it's easy. If not, I choose arbitrarily the first one on the list and set the others to one. ///*)
inverRelUV=Piecewise[{{Quiet[Solve[Table[nonZeroliwcs[[i,1]]==nonZeroliwcs[[i,2]],{i,1,Length[nonZeroliwcs]}],varsUV]],Length[varsUV]==1}},{Join[Quiet[Solve[Table[nonZeroliwcs[[i,1]]==nonZeroliwcs[[i,2]],{i,1,Length[nonZeroliwcs]}]/.Table[varsUV[[j]]->1,{j,2,Length[varsUV]}],varsUV[[1]]]][[1]],Table[varsUV[[j]]->1,{j,2,Length[varsUV]}]]}];
];
avoidZeroSol=Select[inverRelUV,FreeQ[#[[;;,2]],0]&];
(*/// Not interested in solutions that set everything to zero. ///*)
If[Length[avoidZeroSol]>0,
inverRelUV=avoidZeroSol;,
inverRelUV=Select[inverRelUV,(DeleteDuplicates[#[[;;,2]]]!={0})&];
];
inverRelUV
];
computeInvariants1L[dictionary_]:=Block[{zeroWCs,invarsToRet,nonZeroWCs,varsUV,indexNonZeroWCs,monoList,monoBase,nonZeroWCsMonoBase,relSolWCs,unrelWCs,ldWCs,relMatWCs,indepRelWCs,listRelWCs,WCstoElim,indElim,inspectRow,numSquareds,invarsUV,indexSquareds,posSquaredsindexSquareds,entangledRows,usedWCs,indEntRows,entangledVars,tabMultRelRed,dictioFinalFull,relatedRows,dictioFinal,unusedWCs,indUnusedWCs,tabSquareds,nonZeroElems,nonZeroCols,flagWC,indCol,dependWC,nonZeroLIWCs,reempLDWCs,nonZeroLIWCsMonoBase,monoWCsBase,\[Alpha],tabMultRel,findMultRel,listMultRel,varsMultRel,relExp,multRelWCs,flagMultRel,WCstoElimMult,WCstoElimMultRelOrig,wcToElim,posToElim,flagElimCoeff,rowReduced,lowestExp,posLowestExp,posSquareds,reempNonZeroLIWCs,inverRelUV,indRelRows,setVarsUVZero,posCte,listNonZeroWCsIndepTerm,monoBaseExtended,posConstWCs,nonZeroWCsConstWCs,nonZeroDepWCs,listNonZeroDepWCsIndepTerm,indexNonZeroDepWCs,nonZeroLIWCsNames,listNonZeroLIWCsIndepTerm,solWCs,solToRet},
zeroWCs=Select[dictionary,(#[[2]]==0)&][[;;,1]];
nonZeroWCs=Select[dictionary,(FreeQ[zeroWCs,#[[1]]])&];
invarsToRet={};
solToRet={};
If[Length[nonZeroWCs]>0,
varsUV=DeleteCases[DeleteCases[Variables[nonZeroWCs[[;;,2]]],Symbol[SymbolName[m]]],v];
(*Print[varsUV];*)
setVarsUVZero=Table[varsUV[[i]]:>0,{i,1,Length[varsUV]}];
(*// Part that receives the expression for the couplings and determines how many of them are non-zero. //*)
indexNonZeroWCs=Table[k,{k,1,Length[nonZeroWCs]}];(*/// Enumerates the non-zero WCs ///*)
monoList=DeleteCases[DeleteDuplicates[Flatten[MonomialList[nonZeroWCs[[;;,2]]/.{Symbol[SymbolName[m]]->1}]]],_?NumericQ];(*/// List of monomials of UV couplings. ///*)
(*Print[monoList];*)
monoBase=DeleteDuplicates[monoList,(wcVarDecomp[#1]==wcVarDecomp[#2])&];(*/// Base of monomials, eliminates duplicates. ///*)
monoBase=N[monoBase]/.{a_?NumericQ*b_^Optional[c_]:>b^c};(*/// Eliminates numerical factors from the monomials. ///*)
(*Print[monoBase];*)
(*///Check if any monomial is a numerical constant.///*)
posCte=Position[monoBase,1];
If[posCte!={},
(*///If so, that monomial will be replaced by the inverse of the squared mass. ///*)
monoBase=Delete[monoBase,posCte[[1,1]]];
monoBaseExtended=Join[monoBase,{invMassSq}];,
monoBaseExtended=monoBase;];
(*///Search for WCs that are set to be constant///*)
listNonZeroWCsIndepTerm=Table[nonZeroWCs[[j,2]]/.setVarsUVZero,{j,1,Length[nonZeroWCs]}];
(*///To make everything easier, let's separate the WCs that are just a constant for constant mass. ///*)
posConstWCs=Flatten[Position[Chop[((nonZeroWCs[[;;,2]]-listNonZeroWCsIndepTerm)/.{Symbol[SymbolName[m]]->1})],0]];
nonZeroWCsConstWCs=nonZeroWCs[[posConstWCs]];
nonZeroDepWCs=Delete[nonZeroWCs,Table[{posConstWCs[[j]]},{j,1,Length[posConstWCs]}]];
indexNonZeroDepWCs=Table[k,{k,1,Length[nonZeroDepWCs]}];
(*/// Enumerates the WCs that are non-zero and depend on UV variables. ///*)
listNonZeroDepWCsIndepTerm=Delete[listNonZeroWCsIndepTerm,Table[{posConstWCs[[j]]},{j,1,Length[posConstWCs]}]];
(*/// Table with the decomposition of the non-zero non-constant WCs in the base of monomials. The part independent of the UV couplings has been substracted.///*)
nonZeroWCsMonoBase=Table[Coefficient[Simplify[(nonZeroDepWCs[[j,2]]-listNonZeroDepWCsIndepTerm[[j]])(*/.{m\[Rule]1}*)],monoBase[[i]]],{j,1,Length[nonZeroDepWCs]},{i,1,Length[monoBase]}];
(*/// From decomposing in that base, I can find the linear relations among WCs. The Rationalize is not needed in general for tree-level matching, but it is left to future-proof this.///*)
relSolWCs=Table[Quiet[Solve[Rationalize[nonZeroWCsMonoBase[[i]]==Sum[\[Alpha][i,j]*nonZeroWCsMonoBase[[j]],{j,DeleteCases[indexNonZeroDepWCs,i]}],10^(-$MachinePrecision)],Table[\[Alpha][i,j],{j,DeleteCases[indexNonZeroDepWCs,i]}]]],{i,1,Length[nonZeroDepWCs]}];
(*/// Select the WCs that are linearly independent and are not related to any other.///*)
unrelWCs=Select[nonZeroDepWCs[[;;,1]],(relSolWCs[[Position[nonZeroDepWCs[[;;,1]],#][[1,1]]]]=={})&];
(*/// List of WCs that are linearly related to others. ///*)
ldWCs=Select[nonZeroDepWCs[[;;,1]],(FreeQ[unrelWCs,#])&];
(*/// If there are WCs linearly related among them, I have to go to a basis. ///*)
If[Length[unrelWCs]<Length[nonZeroDepWCs],
(*/// Table with all the relations among the WCs.  ///*)
relMatWCs=Table[Piecewise[{{-1,i==j}},\[Alpha][i,j]],{i,1,Length[nonZeroDepWCs]},{j,1,Length[nonZeroDepWCs]}]/.Flatten[relSolWCs]/.{\[Alpha][_,_]->0};
(*/// Select a subset of LI relations among WCs. ///*)
indepRelWCs=Select[RowReduce[relMatWCs],(#!=0*UnitVector[Length[nonZeroDepWCs],1]&&FreeQ[Table[UnitVector[Length[nonZeroDepWCs],i],{i,1,Length[nonZeroDepWCs]}],#])&];
(*/// Write explicitly a list of relations among the WCs. ///*)
listRelWCs=Table[Sum[indepRelWCs[[i,j]]*(nonZeroDepWCs[[j,1]]-listNonZeroDepWCsIndepTerm[[j]]),{j,1,Length[nonZeroDepWCs]}]==0,{i,1,Length[indepRelWCs]}];
(*/// replacements to use for the LD WCs and determination of the LI ones. ///*)
reempLDWCs=Quiet[Solve[Chop[listRelWCs],nonZeroDepWCs[[;;,1]]]];
nonZeroLIWCsNames=Variables[reempLDWCs[[1,;;,2]]/.{Symbol[SymbolName[m]]->1}];
(*/// List of the LI non-zero WCs that have been selected. ///*)
nonZeroLIWCs=Select[nonZeroDepWCs,(MemberQ[nonZeroLIWCsNames,#[[1]]]||MemberQ[unrelWCs,#[[1]]])&];
listNonZeroLIWCsIndepTerm=Table[nonZeroLIWCs[[j,2]]/.setVarsUVZero,{j,1,Length[nonZeroLIWCs]}];
WCstoElim=Complement[nonZeroDepWCs,nonZeroLIWCs];
(*/// Table with the decomposition of the non-zero WCs in the base of monomials. ///*)
nonZeroLIWCsMonoBase=Table[Coefficient[(nonZeroLIWCs[[j,2]]-listNonZeroLIWCsIndepTerm[[j]])(*/.{m\[Rule]1}*),monoBase[[i]]],{j,1,Length[nonZeroLIWCs]},{i,1,Length[monoBase]}];
,
(*/// If all the non-zero WCs are LI, just rename the table. ///*)
nonZeroLIWCs=nonZeroDepWCs;
nonZeroLIWCsMonoBase=nonZeroWCsMonoBase;]; (* End of the If[unrelWCs<nonZeroWCs]*)
invarsToRet=invariantBuilder[monoBase,nonZeroLIWCsMonoBase];
Print[invarsToRet];
solWCs=Quiet[Solve[Table[nonZeroLIWCs[[i,1]]==nonZeroLIWCs[[i,2]],{i,1,Length[nonZeroLIWCs]}],DeleteDuplicates[Variables[monoBase]]]];
(*Print[Table[nonZeroLIWCs[[i,1]]==nonZeroLIWCs[[i,2]],{i,1,Length[nonZeroLIWCs]}]];*)
If[Length[solWCs]>0,solToRet=solWCs,
(*solToRet=inverRelUVGen[nonZeroLIWCs,monoBase];*)
solToRet={};
If[Length[solToRet]==0,
Print["WARNING, couldn't find any solution for the UV couplings in terms of the WCs"];];];
];(*End of the If Length[nonZeroWCs]>0*)
{invarsToRet,solToRet}]


(* ::Section:: *)
(*Run card printing*)


(* ::Subsection:: *)
(*UV scan run card printing*)


dictPrinterUVcoup[matchResFile_,mass_,varsUVinp_:{},flaUVassum_:{},collection_:"UserCollection",model_:"UserModel"]:=Block[{indFree,massString,dicTotal,simpleUVnames,preVarsUV,varsUV,str1,indWCzero,ind1,invarsUV,inverRelUV,reempNamesRelev,zeroWCs,nonZeroWCs,massReemp},
(*Load the dictionary with tree-level matching results*)
(*preVarsUV=Piecewise[{{parametersListFromMatchingResult[matchResFile],varsUVinp=={}}},varsUVinp]; (*// Will be useful for the masses //*)*)
preVarsUV=parametersListFromMatchingResult[matchResFile][[1]];
{dicTotal,massString,massReemp}=massHandler[matchResFile,mass,flaUVassum];
varsUV=DeleteDuplicates[Variables[dicTotal[[;;,2]]/.massReemp]];
(*Get simpler names for the UV variables. *)
simpleUVnames=simplifyUVcoupNames[Replace[varsUV,{a_[b__]:>a},1]];
(*Apply them*)
dicTotal=dicTotal/.simpleUVnames;
varsUV=varsUV/.simpleUVnames;
(*Print the card*)
If[Length[varsUV]>0,
str1=OpenWrite[NotebookDirectory[]<>"//out_UV_dict_Coll_"<>collection<>"_Mod_"<>ToString[model]<>"_Mass_"<>massString<>"_1Loop.yaml"];
WriteLine[str1,"# UV dictionary with WCs in terms of UV variables"];
WriteLine[str1,"# ~~~~~~~~~~~~~~~~~~~~~~"];
WriteLine[str1,"UV Collection : "<>collection];
WriteLine[str1,"UV model : "<>model];
WriteLine[str1,"Model name : "<>model];
WriteLine[str1,"# ~~~~~~~~~~~~~~~~~~~~~~"];
WriteLine[str1,"UV couplings : "<>StringReplace[ToString[InputForm[Table[CForm[varsUV[[k]]],{k,1,Length[varsUV]}]]],{"{"->"[","}"->"]","*^"->"e"}]];
WriteLine[str1,"UV masses : "<>StringReplace[ToString[InputForm[Table[CForm[preVarsUV[[k]]],{k,1,Length[preVarsUV]}]]],{"{"->"[","}"->"]","*^"->"e"}]];
WriteLine[str1,"# ~~~~~~~~~~~~~~~~~~~~~~"];
WriteLine[str1,"# Loop level of the results : 1"];
WriteLine[str1,"# ~~~~~~~~~~~~~~~~~~~~~~"];
WriteLine[str1,"# Setting of the UV mass in TeV:"];
WriteLine[str1,"m : "<>ToString[mass]<>" TeV"];
WriteLine[str1,"# ~~~~~~~~~~~~~~~~~~~~~~"];
WriteLine[str1,"# Expressions for all the WCs in SMEFiT basis"];
For[ind1=1,ind1<=Length[dicTotal],ind1++,
WriteLine[str1,printNameWCs[dicTotal[[ind1,1]]]<>" : "<>"["<>StringRiffle[funcRemoveZeros[Flatten[MapIndexed[writeStrBlock[varsUV],CoefficientList[N[dicTotal[[ind1,2]]/.massReemp],varsUV],{Length[varsUV]}]]],","]<>"]"]];
WriteLine[str1,"# ~~~~~~~~~~~~~~~~~~~~~~"];
WriteLine[str1,"# Miscellaneous information"];
WriteLine[str1,"# Tree-level results address: "<>matchResFile];
WriteLine[str1,"# Export date: "<>DateString[]];
Close[str1];
{invarsUV,inverRelUV}=computeInvariants1L[Chop[(dicTotal/.massReemp)]];
zeroWCs=Select[dicTotal,(#[[2]]==0)&][[;;,1]];
nonZeroWCs=Select[dicTotal,(FreeQ[zeroWCs,#[[1]]])&];
reempNamesRelev=Table[nonZeroWCs[[i,1]]->ToExpression[printNameWCs[nonZeroWCs[[i,1]]]],{i,1,Length[nonZeroWCs]}];
invarFilePrinter[model,collection,0,massString,invarsUV,{},reempNamesRelev];
];];


(* ::Subsection:: *)
(*WC scan run card printing*)


dictPrinterWCscanV2[matchResFile_,mass_,varsUVinp_:{},flaUVassum_:{},collection_:"UserCollection",model_:"UserModel"]:=Block[{dictionary,zeroWCs,nonZeroWCs,varsUV,indexNonZeroWCs,monoList,monoBase,nonZeroWCsMonoBase,relSolWCs,unrelWCs,ldWCs,defSignList,posPosWCs,posNegWCs,relMatWCs,
indepRelWCs,listRelWCs,WCstoElim,indElim,inspectRow,linearBase,nonZeroCols,flagWC,indCol,dependWC,nonZeroLIWCs,tabMultRel,findMultRel,listMultRel,varsMultRel,relExp,numFact,numFactRel,flagMultRel,str1,indWCzero,indWCnonzero,indWCunrel,indWCrel,indWCpos,indWCneg,indRel,indWCnonzeroLI,
reempLDWCs,WCstoElimMult,WCstoElimMultStr,WCstoElimMultRelOrig,posToElim,flagElimCoeff,rowReduced,lowestExp,posLowestExp,wcToElim,dictioFinal,inverRelUV,tabMultRelRed,posSquareds,preVarsUV,numSquareds,invarsUV,indexSquareds,entangledRows,entangledVars,relatedRows,indEntRows,indRelRows,
indUVcoup,listInvarsUVoutForm,nonZeroLIWCsMonoBase,monoWCsBase,reempNonZeroLIWCs,massString,massReemp,dictioFinalFull,solDictioFinal,wCsDictioFinal,multRelWCs,reempNamesRelev,tabSquareds,indUnusedWCs,usedWCs,nonZeroElems,unusedWCs,reempWCsMultRel,provExp,simpleUVnames,indFree,namePosWCs,nameNegWCs,reempWCsMultRelSimp},
preVarsUV=Piecewise[{{parametersListFromMatchingResult[matchResFile],varsUVinp=={}}},varsUVinp];
(*dictionary=dictionaryToPrint[matchResFile]/.{Symbol[SymbolName[onelooporder]]->0}/.flaUVassum;*)
{dictionary,massString,massReemp}=massHandler[matchResFile,mass,flaUVassum];
massReemp=Rationalize[massReemp];
varsUV=DeleteDuplicates[Variables[dictionary[[;;,2]]/.massReemp]];
(*Get simpler names for the UV variables. *)
simpleUVnames=simplifyUVcoupNames[Replace[varsUV,{a_[b__]:>a},1]];
(*Apply them*)
dictionary=dictionary/.simpleUVnames;
varsUV=varsUV/.simpleUVnames;
(*// Part that receives the dictionary and determines which WCs have to be set to zero and which ones not //*)
zeroWCs=Select[dictionary,(#[[2]]==0)&][[;;,1]];
nonZeroWCs=Chop[Rationalize[Select[dictionary,(FreeQ[zeroWCs,#[[1]]])&]]/.massReemp];
reempWCsMultRel={};
WCstoElimMult={};
If[Length[nonZeroWCs]>0,
(*// Part that receives the expression for the couplings and determines  how many of them are non-zero //*)
If[Length[nonZeroWCs]>1,indexNonZeroWCs=Table[k,{k,1,Length[nonZeroWCs]}];
(*// Decompose the WCs in the base of monomials to find linear relations. //*)
monoList=DeleteDuplicates[Flatten[MonomialList[nonZeroWCs[[;;,2]]/.massReemp]]];
monoBase=DeleteDuplicates[monoList,(wcVarDecomp[#1]==wcVarDecomp[#2])&];
monoBase=Table[Rationalize[monoBase[[k]]]/FactorTermsList[Rationalize[monoBase[[k]]]][[1]],{k,1,Length[monoBase]}];
nonZeroWCsMonoBase=Table[Coefficient[nonZeroWCs[[j,2]]/.massReemp,monoBase[[i]]],{j,1,Length[nonZeroWCs]},{i,1,Length[monoBase]}];
relSolWCs=Table[Quiet[Solve[nonZeroWCsMonoBase[[i]]==Sum[\[Alpha][i,j]*nonZeroWCsMonoBase[[j]],{j,DeleteCases[indexNonZeroWCs,i]}],Table[\[Alpha][i,j],{j,DeleteCases[indexNonZeroWCs,i]}]]],{i,1,Length[nonZeroWCs]}];
unrelWCs=Select[nonZeroWCs[[;;,1]],(relSolWCs[[Position[nonZeroWCs[[;;,1]],#][[1,1]]]]=={})&];
ldWCs=Select[nonZeroWCs[[;;,1]],(FreeQ[unrelWCs,#])&];
If[Length[unrelWCs]<Length[nonZeroWCs],
relMatWCs=Table[Piecewise[{{-1,i==j}},\[Alpha][i,j]],{i,1,Length[nonZeroWCs]},{j,1,Length[nonZeroWCs]}]/.Flatten[relSolWCs]/.{\[Alpha][_,_]->0};
indepRelWCs=Select[RowReduce[relMatWCs],(#!=0*UnitVector[Length[nonZeroWCs],1]&&FreeQ[Table[UnitVector[Length[nonZeroWCs],i],{i,1,Length[nonZeroWCs]}],#])&];
listRelWCs=Table[Sum[indepRelWCs[[i,j]]*nonZeroWCs[[j,1]],{j,1,Length[nonZeroWCs]}]==0,{i,1,Length[indepRelWCs]}];
WCstoElim={};
For[indElim=1,indElim<=Length[indepRelWCs],indElim++,
inspectRow=indepRelWCs[[-indElim]];
nonZeroElems=Select[inspectRow,UnsameQ[#,0]&];
nonZeroCols=Table[Position[inspectRow,nonZeroElems[[i]]][[1,1]],{i,1,Length[nonZeroElems]}];
flagWC=1;
indCol=1;
While[flagWC==1&&indCol<=Length[nonZeroCols],
dependWC=nonZeroWCs[[nonZeroCols[[-indCol]],1]];
If[FreeQ[WCstoElim,dependWC],
AppendTo[WCstoElim,{dependWC,nonZeroCols[[-indCol]]}];
flagWC=0;,
indCol+=1;];];];
nonZeroLIWCs=Delete[nonZeroWCs,Table[{WCstoElim[[k,2]]},{k,1,Length[WCstoElim]}]];
reempLDWCs=Solve[listRelWCs,WCstoElim[[;;,1]]][[1]];,
nonZeroLIWCs=nonZeroWCs];
(*// Rotate to a base of pseudo-WCs that agree with the monomials//*)
If[Length[monoBase]==Length[nonZeroLIWCs],
nonZeroLIWCsMonoBase=Table[Coefficient[nonZeroLIWCs[[j,2]],monoBase[[i]]],{j,1,Length[nonZeroLIWCs]},{i,1,Length[monoBase]}];
monoWCsBase=Inverse[nonZeroLIWCsMonoBase] . nonZeroLIWCs[[;;,1]];,
monoWCsBase=nonZeroLIWCs[[;;,1]];
Print["WARNING: The base of LI WCs doesn't match in dimensions the one of monomials, hence the rotation can't be done properly."]];
(*// Part that detects additional non-linear relations among WCs //*)
Module[{pseudoWC},
tabMultRel=Table[Exponent[monoBase[[i]],varsUV[[j]]],{i,1,Length[monoBase]},{j,1,Length[varsUV]}];
If[MatrixRank[tabMultRel]<Length[monoBase],
findMultRel=Quiet[Solve[tabMultRel[[1]]*0==Sum[\[Alpha][j]*tabMultRel[[j]],{j,1,Length[tabMultRel]}],Table[\[Alpha][k],{k,1,Length[tabMultRel]}]]];
listMultRel=Table[\[Alpha][i],{i,1,Length[tabMultRel]}]/.findMultRel;
varsMultRel=Variables[listMultRel];
relExp=Flatten[Table[listMultRel/.Table[varsMultRel[[i]]->If[i==j,1,0],{i,1,Length[varsMultRel]}],{j,1,Length[varsMultRel]}],1];
If[Length[varsMultRel]!=Length[monoBase]-MatrixRank[tabMultRel],Print["There's something wrong, there might be additional multip. relations."]];
(*/// Assume pseudoWC[i] = monoWCsBase[[i]] ///*)
multRelWCs=Table[Product[pseudoWC[i]^(relExp[[j,i]]),{i,1,Length[monoWCsBase]}],{j,1,Length[relExp]}];
flagMultRel=1;,flagMultRel=0;];
(*// Algorithm to pick WCs to eliminate, i.e. that will be dependent quantities, from the multiplicative relations. //*)
WCstoElimMult={};
WCstoElimMultRelOrig={};
If[flagMultRel==1,
For[indElim=1,indElim<=Length[relExp],indElim++,
inspectRow=relExp[[-indElim]];
posToElim={};
flagElimCoeff=0;
While[flagElimCoeff==0 && Length[posToElim]<Length[inspectRow],
rowReduced=Delete[inspectRow,posToElim];
lowestExp=findLowestExponent[rowReduced];
posLowestExp=Position[inspectRow,lowestExp][[1,1]];
wcToElim=pseudoWC[posLowestExp];
If[MemberQ[WCstoElimMult,wcToElim],
AppendTo[posToElim,posLowestExp];,
AppendTo[WCstoElimMult,wcToElim];
AppendTo[WCstoElimMultRelOrig,-indElim];
flagElimCoeff=1;];];];];
(*// Replacements for the WCs to be eliminated from mult. relations. //*)
reempWCsMultRel=Table[Solve[1==multRelWCs[[WCstoElimMultRelOrig[[k]]]],WCstoElimMult[[k]]][[1,1]],{k,1,Length[WCstoElimMult]}];
reempWCsMultRelSimp=reempWCsMultRel/.Table[pseudoWC[i]->monoWCsBase[[i]],{i,1,Length[monoWCsBase]}];
reempWCsMultRelSimp=Simplify[Solve[Table[reempWCsMultRelSimp[[i,1]]==reempWCsMultRelSimp[[i,2]],{i,1,Length[reempWCsMultRelSimp]}],Select[Variables[reempWCsMultRelSimp[[;;,1]]],(StringMatchQ[SymbolName[#],"ww*"])&]][[1]],{Symbol[SymbolName[m]]>0}];
(*// Defining dictionary with the WCs to be fitted. //*)
(*// Adding step to take out overall numerical factors from the rotation //*)
dictioFinal=Table[monoWCsBase[[i]],{i,Select[Table[k,{k,1,Length[monoWCsBase]}],(!MemberQ[WCstoElimMult/.{a_[b_]:>b},#])&]}];
wCsDictioFinal=DeleteDuplicates[DeleteCases[Variables[dictioFinal],Symbol[SymbolName[m]]]];
reempNonZeroLIWCs=Table[nonZeroLIWCs[[i,1]]->nonZeroLIWCs[[i,2]],{i,1,Length[nonZeroLIWCs]}];
solDictioFinal=Quiet[Solve[Table[dictioFinal[[i]]==(dictioFinal[[i]]/.reempNonZeroLIWCs),{i,1,Length[dictioFinal]}],wCsDictioFinal]];
dictioFinalFull=Table[{wCsDictioFinal[[i]],wCsDictioFinal[[i]]/.solDictioFinal[[1]]},{i,1,Length[wCsDictioFinal]}];];
{invarsUV,inverRelUV}=computeInvariants1L[Chop[(dictionary/.massReemp)]];
,
invarsUV=Piecewise[{{nonZeroWCs[[1,2]]*mass^2,Length[varsUV]>1}},varsUV];
tabSquareds=Flatten[Table[Exponent[nonZeroWCs[[i,2]],varsUV[[j]]],{i,1,Length[nonZeroWCs]},{j,1,Length[varsUV]}]];
If[MemberQ[tabSquareds,2]&&Length[varsUV]==1,
invarsUV={Abs[varsUV[[Position[tabSquareds,2][[1,1]]]]]};,
invarsUV={mass^2*nonZeroWCs[[1,2]]};];
inverRelUV=Piecewise[{{Solve[Join[Table[nonZeroWCs[[i,1]]==nonZeroWCs[[i,2]],{i,1,Length[nonZeroWCs]}]],varsUV],Length[varsUV]==1}},{{AA->AA}}];
dictioFinalFull=nonZeroWCs;
dictioFinal=dictioFinalFull[[;;,1]];
unrelWCs=nonZeroWCs[[;;,1]];
];
defSignList=Table[testSign[nonZeroWCs[[i,2]]/.massReemp],{i,1,Length[nonZeroWCs]}];
posPosWCs=Flatten[Position[defSignList,"Pos"]];
posNegWCs=Flatten[Position[defSignList,"Neg"]];
];
linearBase=nonZeroLIWCs[[;;,1]](*Join[dictioFinal,WCstoElimMult]*);
reempNamesRelev=Table[nonZeroWCs[[i,1]]->ToExpression[printNameWCs[nonZeroWCs[[i,1]]]],{i,1,Length[nonZeroWCs]}];
namePosWCs=Piecewise[{{nonZeroWCs[[posPosWCs,1]],Length[posPosWCs]>0}},{}];
nameNegWCs=Piecewise[{{nonZeroWCs[[posNegWCs,1]],Length[posNegWCs]>0}},{}];
invarFilePrinter[model,collection,0,massString,invarsUV,inverRelUV/.massReemp,reempNamesRelev];
str1=OpenWrite[NotebookDirectory[]<>"//dict_WC_scan_Coll_"<>collection<>"_Mod_"<>model<>"_Mass_"<>massString<>"_Tree"<>".yaml"];
WriteLine[str1,"# UV dictionary for WC scan. Tree-level matching."];
WriteLine[str1,"# ~~~~~~~~~~~~~~~~~~~~~~"];
WriteLine[str1,"UV Collection : "<>collection];
WriteLine[str1,"UV model : "<>model];
WriteLine[str1,"Model name : "<>model];
WriteLine[str1,"# ~~~~~~~~~~~~~~~~~~~~~~"];
WriteLine[str1,"# Loop level of the results : "<>ToString[0(*loop*)]];
WriteLine[str1,"# ~~~~~~~~~~~~~~~~~~~~~~"];
WriteLine[str1,"# Setting of the UV mass in TeV:"];
WriteLine[str1,"m : "<>ToString[mass]<>" TeV"];
WriteLine[str1,"# ~~~~~~~~~~~~~~~~~~~~~~"];
WriteLine[str1,"# Free coefficients"];
WriteLine[str1,"# ~~~~~~~~~~~~~~~~~~~~~~"];
If[Length[dictioFinal]>0,
For[indFree=1,indFree<=Length[dictioFinal],indFree++,
WriteLine[str1,printNameWCs[dictioFinalFull[[indFree,1]]]<>": "<>Piecewise[{{"{min: 0.0, max: 100.0}",MemberQ[namePosWCs,dictioFinalFull[[indFree,1]]]},{"{min: -100.0, max: 0.0}",MemberQ[nameNegWCs,dictioFinalFull[[indFree,1]]]}},"{min: -100.0, max: 100.0}"]]];];
WriteLine[str1,"# ~~~~~~~~~~~~~~~~~~~~~~"];
WriteLine[str1,"# Constrained coefficients"];
WriteLine[str1,"# ~~~~~~~~~~~~~~~~~~~~~~"];
If[Length[nonZeroWCs]>0,
If[Length[unrelWCs]<Length[nonZeroWCs],If[Length[indepRelWCs]>0,For[indWCrel=1,indWCrel<=Length[WCstoElim[[;;,1]]],indWCrel++,
provExp=Flatten[MapIndexed[writeStrBlock[linearBase],CoefficientList[N[WCstoElim[[indWCrel,1]]/.reempLDWCs/.massReemp],linearBase],{Length[linearBase]}]];
WriteLine[str1,printNameWCs[WCstoElim[[indWCrel,1]]]<>":\n\t constrain: ["<>StringRiffle[DeleteCases[Table[reempMultRelPrint[provExp[[l]],dictioFinalFull[[;;,1]],reempWCsMultRelSimp,reempNamesRelev],{l,1,Length[provExp]}],(a_/;(reCastString[a][[1,2]]==0))],","]<>"]"];]];];
,WriteLine[str1," "];];
If[Length[nonZeroWCs]>0&&Length[WCstoElimMult]>0,
For[indRel=1,indRel<=Length[WCstoElimMult],indRel++,
WriteLine[str1,printNameWCs[reempWCsMultRelSimp[[indRel,1]]]<>":\n\t constrain: ["<>printMultRelNew[reempWCsMultRelSimp[[indRel]],dictioFinalFull[[;;,1]],reempNamesRelev]<>"]"];]];
For[indWCzero=1,indWCzero<=Length[zeroWCs],indWCzero++,
WriteLine[str1,printNameWCs[zeroWCs[[indWCzero]]]<>":\n\t constrain: true\n\t value: 0.0"];];
WriteLine[str1,"# ~~~~~~~~~~~~~~~~~~~~~~"];
WriteLine[str1,"# Miscellaneous information"];
WriteLine[str1,"# Tree-level results address: "<>matchResFile];
WriteLine[str1,"# Export date: "<>DateString[]];
Close[str1];]


(* ::Subsection::Closed:: *)
(*Invariant printing*)


(*/// Set of functions to print the UV invariants cards. ///*)
(*/// Invariant printing ///*)
replacementsPreFortran={Surd[a_,b_]:>a^(1/b)};
listPythonFunctionNames={"Abs"->"np.abs","Sqrt"->"np.emath.sqrt","Log"->"np.log","Sin"->"np.sin","Cos"->"np.cos",
"Tan"->"np.tan","ArcCos"->"np.arccos","ArcSin"->"np.arcsin","ArcTan"->"np.arctan",
"Sinh"->"np.sinh",
"Cosh"->"np.cosh",
"Tanh"->"np.tanh",
"ArcCosh"->"np.arccosh",
"ArcSinh"->"np.arcsinh",
"ArcTanh"->"np.arctanh",
"(" ~~ a : NumberString ~~ "," ~~ b : NumberString ~~ ")" :> "(" <> a <> Piecewise[{{"", StringMatchQ[StringTake[b, 1], RegularExpression["[+-]"]]}}, "+"] <> b <> "J)"};
invarFilePrinter[part_,collection_,loop_,mass_,invarsUV_,inverRelUV_,reempNamesRelev_]:=Block[{str2,indInvar,uvVarsInInv,strName,indUVcoupInvar,inverRelUVcouPrint,indUVcoup2,auxInvList,accessWCs},
(*Print[reempNamesRelev];*)
str2=OpenWrite[NotebookDirectory[]<>"//InvarsFit_"<>collection<>"_Model_"<>ToString[part]<>"_Mass_"<>mass<>"_"<>Piecewise[{{"Loop",loop==1},{"Tree",loop==0}}]<>".py"];
WriteLine[str2,"import numpy as np

from utils import inspect_model


MODEL_SPECS = dict(" ];
WriteLine[str2,"\t id= \""<>ToString[part]<>"\","];
WriteLine[str2,"\t collection= \""<>collection<>"\","];
WriteLine[str2,"\t mass="<>mass<>", # in TeV"];
WriteLine[str2,"\t pto=\"NLO\","];
WriteLine[str2,"\t eft=\"NHO\""];
WriteLine[str2,")\n\n"];
If[Length[invarsUV]>0,
For[indInvar=1,indInvar<=Length[invarsUV],indInvar++,
WriteLine[str2,"def inv"<>ToString[indInvar]<>"(results):"];
uvVarsInInv=DeleteDuplicates[Variables[invarsUV[[indInvar]]]/.{Abs[a_]:>a,Sqrt[a_]:>a,Log[a_]:>a}];
For[indUVcoupInvar=1,indUVcoupInvar<=Length[uvVarsInInv],indUVcoupInvar++,
strName=ToString[uvVarsInInv[[indUVcoupInvar]]];
WriteLine[str2,"\t"<>strName<>" = results."<>strName];];
WriteLine[str2,"\treturn "<>StringReplace[ToString[FortranForm[invarsUV[[indInvar]]/.replacementsPreFortran]],listPythonFunctionNames]<>"\n"];
];];
Close[str2];]


(* ::Section:: *)
(*Public functions*)


(* ::Subsection::Closed:: *)
(*UV to EFT matching*)


(*/// Function that does the matching procedure. ///*)
matcher[directory_,model_]:=Block[{listInputFiles,listResultFiles,listProblems,streamScriptMatch,streamScript1,streamScript2},
(*/// Checking existence of mandatory input files. ///*)
listInputFiles=FileNames[model<>"*",directory];
If[Not[MemberQ[listInputFiles,directory<>model<>".fr"]],
Print["Input file missing.\nThe file defining the model, with extension .fr, can not be found.\nMatchmakerEFT will not be run.\nPlease, check the existence of the file:\n"<>directory<>model<>".fr"];
Return[];];
If[Not[
MemberQ[listInputFiles,directory<>model<>".gauge"]],
Print["The following input file required by MatchmakerEFT can not be found:\n"<>directory<>model<>".gauge"];
Print["MatchmakerEFT will be run but it is expected to fail.\nPlease, check the existence of the missing file and the output in:\n"<>directory<>model<>".log"];];
If[Not[
MemberQ[listInputFiles,directory<>model<>".red"]],
Print["The following input file required by MatchmakerEFT can not be found:\n"<>directory<>model<>".red"];
Print["MatchmakerEFT will be run but it is expected to fail.\nPlease, check the existence of the missing file and the output in:\n"<>directory<>model<>".log"];];
(*/// Writing scripts to run MMEFT ///*)
SetDirectory[directory];
(*/// First script to copy the required base models, SM and SMEFT, included with MMEFT ///*)
streamScript1=OpenWrite[directory<>"script_MMEFT_copymodels"];
WriteLine[streamScript1,"copy_models ."];
WriteLine[streamScript1,"exit"];
Close[streamScript1];
(*/// Second script to place the SM and SMEFT in the right location. ///*)
streamScript2=OpenWrite[directory<>"script_move_models"];
WriteLine[streamScript2,"mv ./MatchMakerEFT/SMEFT_Green_Bpreserving_MM/ ."];
WriteLine[streamScript2,"mv ./MatchMakerEFT/UnbrokenSM_BFM.fr ."];
WriteLine[streamScript2,"rm -r ./MatchMakerEFT/"];
Close[streamScript2];
(*/// Final script to perform the matching. ///*)
streamScriptMatch=OpenWrite[directory<>"script_MMEFT"];
WriteLine[streamScriptMatch,"create_model UnbrokenSM_BFM.fr "<>model<>".fr"];
WriteLine[streamScriptMatch,"match_model_to_eft_onlytree "<>model<>"_MM/ SMEFT_Green_Bpreserving_MM/"];
WriteLine[streamScriptMatch,"exit"];
Close[streamScriptMatch];
(*/// Run Scripts. ///*)
Run["matchmakereft <./script_MMEFT_copymodels"];
Run["bash ./script_move_models"];
Run["matchmakereft <./script_MMEFT"];
(*/// Check existence of results and alert if there was a problem. ///*)
listResultFiles=FileNames["*.dat",directory<>model<>"_MM/"];
If[MemberQ[listResultFiles,directory<>model<>"_MM/MatchingResult.dat"],
Print["The matching results are available in:\n"<>directory<>model<>"_MM/MatchingResult.dat"];
(*/// If successful, delete auxiliar directories and files created by MMEFT and this package ///*)
DeleteDirectory[directory<>model<>"_MM/FORM/",DeleteContents->True];
DeleteDirectory[directory<>model<>"_MM/QGRAF/",DeleteContents->True];
DeleteDirectory[directory<>"SMEFT_Green_Bpreserving_MM/",DeleteContents->True];
DeleteFile[directory<>"script_MMEFT_copymodels"];
DeleteFile[directory<>"script_move_models"];
DeleteFile[directory<>"script_MMEFT"];
DeleteFile[directory<>"UnbrokenSM_BFM.fr"];,
Print["There was a problem during the matching and no results were generated.\nCheck input files."];];
If[MemberQ[listResultFiles,directory<>model<>"_MM/MatchingProblems.dat"],
listProblems=Get[directory<>model<>"_MM/MatchingProblems.dat"];
If[listProblems!={},Print["The matching was completed but problems were reported after internal checks.\nPlease, check the problem list at:\n"<>directory<>model<>"_MM/MatchingProblems.dat\n"<>"Modify the input files in consequence and try again."]],
Print["There was a problem during the matching and no problem list was generated.\nCheck input files."];];];


(* ::Subsection::Closed:: *)
(*UV parameters recognition*)


(*/// Function that reads the .fr file that defines the UV model and identifies the masses and UV couplings.
It returns a list with 2 lists, {listMasses,listUVcouplings}. listMasses is a list with all the masses of the heavy UV particles. 
listUVcouplings is a list with all the couplings defined for those particles. ///*)
parametersList[directory_,model_]:=Block[{listMass,listUVcoup,frFileList,posMasses,listmassesPrel,posListCoup,listcoup},frFileList=StringSplit[Import[directory<>model<>".fr"],{"{","}",",",";","(*","*)"}];
posMasses=Position[frFileList,_?((Quiet[StringCount[#,"Mass    "]]==1)&)]//Flatten;
listmassesPrel=frFileList[[posMasses]];
listMass=StringTrim[StringSplit[StringTrim[listmassesPrel,{"\n","  ",","}],{"->"}][[;;,2]],{" "," "}]//DeleteDuplicates//ToExpression;
posListCoup=(Position[frFileList,_?((Quiet[StringCount[#,"ParameterType"]]==1)&)]//Flatten)-1;
listcoup=StringTrim[StringTrim[frFileList[[posListCoup]],{"\n\n","\t"," "," == "}],{" ","  "}]//DeleteDuplicates//ToExpression;
listUVcoup=Complement[listcoup,listMass];
{listMass,listUVcoup}];
(*/// Function that reads the .dat file with the matching results and identifies the masses and UV couplings.
It takes the address of the MatchingResult.dat file as only input.
It returns a list with 2 lists, {listMasses,listUVcouplings}. listMasses is a list with all the masses of the heavy UV particles. 
listUVcouplings is a list with all the couplings defined for those particles. ///*)
parametersListFromMatchingResult[matchingResultFile_]:=Module[{matchRes,varsSM,listMass,listUVcoup,allVar,allVarSimp,uvVarsComp},
matchRes=Get[matchingResultFile];
allVar=Variables[matchRes[[3]][[;;,2]]];
varsSM={g1,g2,g3,lam,muH,yu,yubar,yd,ydbar,yl,ylbar,KroneckerDelta,onelooporder};
listMass=Select[allVar,(MemberQ[{"m","M"},StringTake[ToString[#],1]]&&FreeQ[Map[SymbolName,varsSM],ToString[#]])&];
allVarSimp=allVar/.{a_[b_]:>a,a_[b_,c_]:>a,a_[b_,c_,d_]:>a,a_[b_,c_,d_,e_]:>a}//DeleteDuplicates;
uvVarsComp=Complement[allVarSimp,Union[listMass,varsSM],SameTest->(SymbolName[#1]==SymbolName[#2]&)];
listUVcoup=DeleteDuplicatesBy[uvVarsComp,(StringReplace[ToString[#],"bar"->""])&];
{listMass,listUVcoup}];


(* ::Subsection::Closed:: *)
(*From model to run card*)


Options[modelToUVscanCard]={"UVFlavourAssumption"->{},"Collection"->"UserCollection"};
modelToUVscanCard[directory_,model_,mass_,OptionsPattern[]]:=Block[{direct},
matcher[directory,model];
If[Characters[directory][[-1]]!="/",direct=directory<>"/",direct=directory];
dictPrinterUVcoup[direct<>model<>"_MM/MatchingResult.dat",mass,parametersList["~/Music/","T1"],OptionValue["UVFlavourAssumption"],OptionValue["Collection"],model];]


Options[modelToWCscanCard]={"UVFlavourAssumption"->{},"Collection"->"UserCollection"};
modelToWCscanCard[directory_,model_,mass_,OptionsPattern[]]:=Block[{direct},
matcher[directory,model];
If[Characters[directory][[-1]]!="/",direct=directory<>"/",direct=directory];
dictPrinterWCscanV2[direct<>model<>"_MM/MatchingResult.dat",mass,parametersList["~/Music/","T1"],OptionValue["UVFlavourAssumption"],OptionValue["Collection"],model];]


(* ::Subsection::Closed:: *)
(*From matching result to run card*)


Options[matchResToUVscanCard]={"UVFlavourAssumption"->{},"Collection"->"UserCollection","Model"->"UserModel"};
Options[matchResToWCscanCard]={"UVFlavourAssumption"->{},"Collection"->"UserCollection","Model"->"UserModel"};
matchResToUVscanCard[matchResFile_,mass_,OptionsPattern[]]:=dictPrinterUVcoup[matchResFile,mass,parametersListFromMatchingResult[matchResFile],OptionValue["UVFlavourAssumption"],OptionValue["Collection"],OptionValue["Model"]]
matchResToWCscanCard[matchResFile_,mass_,OptionsPattern[]]:=dictPrinterWCscanV2[matchResFile,mass,parametersListFromMatchingResult[matchResFile],OptionValue["UVFlavourAssumption"],OptionValue["Collection"],OptionValue["Model"]]


(* ::Section::Closed:: *)
(*Closing the package*)


End[ ];

EndPackage[ ];
