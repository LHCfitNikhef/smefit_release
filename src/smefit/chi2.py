# -*- coding: utf-8 -*-
"""Module for the computation of chi-squared values."""
import json
import pathlib
import importlib
import jax.numpy as jnp
import matplotlib.pyplot as plt
import numpy as np
import scipy.optimize as opt
from rich.progress import track

from smefit.rge import load_rge_matrix
from smefit.utils import NumpyEncoder

from . import compute_theory as pr
from .coefficients import CoefficientManager
from .loader import DataTuple, load_datasets
from .log import logging

_logger = logging.getLogger(__name__)


def compute_chi2(
    dataset,
    coefficients_values,
    use_quad,
    use_multiplicative_prescription,
    use_replica=False,
):
    r"""
    Compute the :math:`\chi^2`.

    Parameters
    ----------
    dataset : DataTuple
        dataset tuple
    coefficients_values : numpy.ndarray
        |EFT| coefficients values
    use_multiplicative_prescription: bool
        if True add the |EFT| contribution as a key factor
    use_quad: bool
        if True include also |HO| corrections
    rgemat: numpy.ndarray
        solution matrix of the RGE

    Returns
    -------
    chi2_total : float
        :math:`\chi^2` value
    """

    # compute theory prediction for each point in the dataset
    theory_predictions = pr.make_predictions(
        dataset, coefficients_values, use_quad, use_multiplicative_prescription
    )

    # compute experimental central values - theory
    if use_replica:
        diff = dataset.Replica - theory_predictions
    else:
        diff = dataset.Commondata - theory_predictions

    invcovmat = dataset.InvCovMat
    # note @ is slower when running with mpiexec
    return jnp.einsum("i,ij,j->", diff, invcovmat, diff)


class Scanner:
    r"""Class to compute and plot the idividual :math:`\chi^2` scan.

    Parameters
    ----------
    run_card : dict
        run card dictionary
    n_replica : int
        number of replica to use
    """

    def __init__(self, run_card, n_replica, scan_points=100):

        self.n_replica = n_replica
        self.use_quad = run_card["use_quad"]
        self.result_path = f"{run_card['result_path']}/{run_card['result_ID']}"
        self.use_multiplicative_prescription = run_card.get(
            "use_multiplicative_prescription", False
        )
        self.mass_scan = False
        self.run_card = run_card

        # set all the coefficients to 0
        self.coefficients = CoefficientManager.from_dict(run_card["coefficients"])
        self.coefficients.set_free_parameters(
            np.full(self.coefficients.free_parameters.shape[0], 0)
        )

        self.rge_dict = run_card.get("rge", None)
        operators_to_keep = run_card["coefficients"]
        self.cutoff_scale = run_card.get("cutoff_scale", None)

        # Here we assume that if a mass is present in the coefficients
        # this is a 1 parameter mass scan only
        if np.any(self.coefficients.is_mass) and self.rge_dict is not None:
            _logger.info("Mass scan detected")
            _logger.info("RGE evolution will be computed for each mass in the scan")
            self.mass_scan = True
            self.rgemat = None
        else:
            if self.rge_dict is not None and run_card.get("datasets") is not None:
                _logger.info("Loading RGE matrix")
                self.rgemat, operators_to_keep = load_rge_matrix(
                    self.rge_dict,
                    list(operators_to_keep.keys()),
                    run_card["datasets"],
                    run_card.get("theory_path", None),
                    self.cutoff_scale,
                )
                _logger.info("The operators generated by the RGE are: ")
                _logger.info(list(operators_to_keep.keys()))
            else:
                self.rgemat = None

        self.datasets = load_datasets(
            run_card["data_path"],
            run_card["datasets"],
            operators_to_keep,
            run_card["use_quad"],
            run_card["use_theory_covmat"],
            False,
            self.use_multiplicative_prescription,
            run_card.get("default_order", "LO"),
            run_card.get("theory_path", None),
            run_card.get("rot_to_fit_basis", None),
            run_card.get("uv_couplings", False),
            run_card.get("external_chi2", False),
            rgemat=self.rgemat,
            cutoff_scale=self.cutoff_scale,
        )

        external_chi2 = run_card.get("external_chi2", None)

        self.chi2_ext = (
            self.load_external_chi2(external_chi2) if external_chi2 else None
        )

        # build empty dict to store results
        self.chi2_dict = {}
        for name, row in self.coefficients.free_parameters.iterrows():
            self.chi2_dict[name] = {}
            self.chi2_dict[name]["x"] = np.linspace(
                row.minimum, row.maximum, scan_points
            )
            self.chi2_dict[name]["n_datapoints"] = self.datasets.Commondata.size

    def load_external_chi2(self, external_chi2):
        """
        Loads the external chi2 modules

        Parameters
        ----------
        external_chi2: dict
            dict of external chi2s, with the name of the function object as key and the path to the external script
            as value

        Returns
        -------
        ext_chi2_modules: list
             List of external chi2 objects that can be evaluated by passing a coefficients instance
        """
        # TODO: this is copied from the Optimiser class, should be moved to a common place

        # dynamical import
        ext_chi2_modules = []

        for class_name, module in external_chi2.items():
            module_path = module["path"]
            path = pathlib.Path(module_path)
            base_path, stem = path.parent, path.stem
            try:
                chi2_module = importlib.import_module(stem)
            except ModuleNotFoundError:
                print(f"Module {stem} not found in {base_path}. Modify the runcard and rerun, exiting")
                exit(1)

            my_chi2_class = getattr(chi2_module, class_name)

            if self.rge_dict is not None:
                # Check if dynamic scale
                if self.rge_dict["obs_scale"] == "dynamic":
                    _logger.info(
                        f"Computing RGE matrix for {class_name} "
                        f"with initial scale {self.rge_dict['init_scale']}."
                    )
                    # compute RGE matrix
                    if "scale" not in module:
                        raise ValueError(
                            "Dynamic scale requested but no scale provided in the external chi2"
                        )
                    scale = module["scale"]
                    rge_runner = RGE(
                        self.coefficients.name,
                        self.rge_dict["init_scale"],
                        self.rge_dict.get("smeft_accuracy", "integrate"),
                    )
                    rge_df = rge_runner.RGEmatrix(scale)
                    gen_operators = list(rge_df.index)
                    _logger.info("The operators generated by the RGE are: ")
                    _logger.info(gen_operators)
                    operators_dict = {
                        k: {"max": 0.0, "min": 0.0} for k in gen_operators
                    }
                    new_coeffs = CoefficientManager.from_dict(operators_dict)
                    chi2_ext = my_chi2_class(new_coeffs, rge_df.values)
                else:
                    gen_operators = list(self.datasets.OperatorsNames)
                    # Create dummy coefficients
                    operators_dict = {
                        k: {"max": 0.0, "min": 0.0} for k in gen_operators
                    }
                    new_coeffs = CoefficientManager.from_dict(operators_dict)
                    chi2_ext = my_chi2_class(new_coeffs, self.rgemat)
            else:
                chi2_ext = my_chi2_class(self.coefficients)

            ext_chi2_modules.append(chi2_ext.compute_chi2)

        return ext_chi2_modules

    def regularized_chi2_func(self, coeff, xs, use_replica):
        r"""Individual :math:`\chi^2` wrappper over series of values.

        Parameters
        ----------
        coeff: `smefit.coefficient.Coefficient`
            coefficient to switch on.
        xs: numpy.array
            coeffient values.
        use_replica: bool
            if True compute the :math:`\chi^2` on |MC| replicas.

        Returns:
        --------
            individual reduced :math:`\chi^2` for each x value.

        """
        chi2_list = []
        for x in xs:
            coeff.value = x
            self.coefficients.set_constraints()
            chi2_list.append(
                compute_chi2(
                    self.datasets,
                    self.coefficients.value,
                    self.use_quad,
                    self.use_multiplicative_prescription,
                    use_replica,
                )
            )
        return np.array(chi2_list)

    def chi2_mass_scan(self, coeff, xs):

        chi2_list = []
        for x in xs:
            coeff.value = x
            self.coefficients.set_constraints()
            # compute rge matrix
            _logger.info("Loading RGE matrix")
            # assuming that the mass is in TeV
            self.rge_dict.update({"init_scale": x * 1e3})
            rgemat, operators_to_keep = load_rge_matrix(
                self.rge_dict,
                list(self.run_card["coefficients"].keys()),
                self.run_card["datasets"],
                self.run_card.get("theory_path", None),
                self.cutoff_scale,
            )
            _logger.info("The operators generated by the RGE are: ")
            _logger.info(list(operators_to_keep.keys()))

            self.datasets = load_datasets(
                self.run_card["data_path"],
                self.run_card["datasets"],
                operators_to_keep,
                self.run_card["use_quad"],
                self.run_card["use_theory_covmat"],
                False,
                self.use_multiplicative_prescription,
                self.run_card.get("default_order", "LO"),
                self.run_card.get("theory_path", None),
                self.run_card.get("rot_to_fit_basis", None),
                self.run_card.get("uv_couplings", False),
                self.run_card.get("external_chi2", False),
                rgemat=rgemat,
                cutoff_scale=self.cutoff_scale,
            )

            chi2_tot = compute_chi2(
                self.datasets,
                self.coefficients.value,
                self.use_quad,
                self.use_multiplicative_prescription,
                use_replica=False,
            )

            if self.chi2_ext is not None:
                for chi2_ext in self.chi2_ext:
                    chi2_ext_i = chi2_ext(self.coefficients.value)
                    chi2_tot += chi2_ext_i

            chi2_list.append(chi2_tot)

        return np.array(chi2_list)

    def compute_bounds(self):
        r"""Compute individual bounds solving.

        ..math::
            \chi^2`- 2 = 0
        """

        # chi^2 - 3.841
        def chi2_func(xs):
            return self.regularized_chi2_func(coeff, xs, False) - 3.841

        # find the bound for each coefficient
        bounds = {}
        x0_interval = [-1000, 1000]
        for coeff in self.coefficients:
            if coeff.name not in self.chi2_dict:
                continue
            coeff.is_free = True
            roots = opt.newton(
                chi2_func,
                x0_interval,
                maxiter=400,
            )
            # test roots are not the same
            try:
                np.testing.assert_allclose(roots[0] - roots[1], 0, atol=1e-5)
                raise ValueError(
                    f"single bound found for {coeff.name}: {roots[0]} in range {x0_interval}."
                )
            except AssertionError:
                # test roots are sorted
                try:
                    np.testing.assert_allclose(roots, np.sort(roots))
                except AssertionError:
                    raise ValueError(
                        f"Bound found for {coeff.name}: {roots} are not sorted."
                    )

            # save bounds and update the x ranges
            bounds[coeff.name] = roots.tolist()
            self.chi2_dict[coeff.name]["x"] = np.linspace(roots[0], roots[1], 100)

            coeff.is_free = False
            coeff.value = 0.0
            _logger.info(f"chi^2 bounds for {coeff.name}: {roots}")

        with open(f"{self.result_path}/chi2_bounds.json", "w", encoding="utf-8") as f:
            json.dump(bounds, f)

    def compute_scan(self):
        r"""Compute the individual :math:`\chi^2` scan for each replica and coefficient."""
        # loop on replicas

        for rep in track(
            range(self.n_replica + 1),
            description="[green]Computing chi2 for each replica...",
        ):
            use_replica = rep != 0
            if use_replica:
                self.datasets = DataTuple(
                    self.datasets.Commondata,
                    self.datasets.SMTheory,
                    self.datasets.OperatorsNames,
                    self.datasets.LinearCorrections,
                    self.datasets.QuadraticCorrections,
                    self.datasets.ExpNames,
                    self.datasets.NdataExp,
                    self.datasets.InvCovMat,
                    np.random.multivariate_normal(
                        self.datasets.Commondata,
                        np.linalg.inv(self.datasets.InvCovMat),
                    ),
                )

            # loop on coefficients
            for coeff in self.coefficients:
                if coeff.name not in self.chi2_dict:
                    continue
                if self.mass_scan:
                    self.chi2_dict[coeff.name][rep] = self.chi2_mass_scan(
                        coeff, self.chi2_dict[coeff.name]["x"]
                    )
                else:
                    self.chi2_dict[coeff.name][rep] = self.regularized_chi2_func(
                        coeff, self.chi2_dict[coeff.name]["x"], use_replica
                    )
                # Parameter is scanned,
                # reset to 0 to not affect the next scan
                coeff.value = 0.0

    def write_scan(self):
        r"""Write the :math:`\chi^2` scan to json file."""
        with open(f"{self.result_path}/chi2_scan.json", "w", encoding="utf-8") as f:
            json.dump(self.chi2_dict, f, cls=NumpyEncoder, indent=4)

    def plot_scan(self):
        r"""Plot and save the :math:`\chi^2` scan for each coefficient."""
        # loop on coefficients
        for c, tab in self.chi2_dict.items():
            _logger.info(f"Plotting scan for {c}")
            plt.figure()
            for rep in range(self.n_replica + 1):
                chi2_min = np.array(tab[rep]).min()
                if rep == 0:
                    plt.plot(tab["x"], tab[rep] - chi2_min)
                else:
                    plt.plot(
                        tab["x"], tab[rep] - chi2_min, alpha=0.2, color="lightskyblue"
                    )

            plt.ylabel(r"$\chi^2 - \chi^2_{min}$")
            plt.hlines(
                0, tab["x"].min(), tab["x"].max(), ls="dotted", color="black", lw=0.5
            )
            plt.title(f"{c}")
            plt.tight_layout()
            plt.savefig(f"{self.result_path}/chi2_scan_{c}.png")
            plt.savefig(f"{self.result_path}/chi2_scan_{c}.pdf")
